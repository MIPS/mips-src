acinclude.m4:sinclude(../config/gettext-sister.m4)
ada-exp.c:   if the built-in stack extension method is used).
ada-exp.y: /* The following are right-associative only so that reductions at this
ada-lang.c:         the GNAT front-end in protected object subprograms.  */
ada-lang.c:       /* This is a (right-justified) modular type representing a packed
ada-lang.c: 	 the (left-justified) packed array type we just built, we must
ada-lang.c: 	 first left-justify it.  */
ada-lang.c:          /* ... And are placed at the beginning (most-significant) bytes
ada-lang.c:   type void has any effect---causing procedures to be preferred over
ada-lang.c:   with their resolutions, replacing built-in operators with
ada-lang.c:  int length = (global ? pst->n_global_syms : pst->n_static_syms);
ada-lang.c:           pst->objfile->global_psymbols.list + pst->globals_offset :
ada-lang.c:           pst->objfile->static_psymbols.list + pst->statics_offset);
ada-lang.c:  for (last = suffix - 3; last > name; last--)
ada-lang.c:   any) in which they were found.  This vector are transient---good only to 
ada-lang.c:   parent-type (inherited) fields of a derived type.  Assumes TYPE is
ada-lang.c:      /* NOTE: result---the fixed version of elt_type0---should never
ada-lang.c:    error (_("Left-hand side must be array or record."));
ada-lang.h:/* Ada task control block, as defined in the GNAT runt-time library.  */
ada-lex.c:/* Number of entries by which start-condition stack grows. */
ada-lex.c:			"out of memory expanding start-condition stack" );
ada-lex.c:		YY_FATAL_ERROR( "start-condition stack underflow" );
ada-typeprint.c:/* Print the choices encoded by field FIELD_NUM of variant-part TYPE on
aix-thread.c:/* This module's target-specific operations, active while pd_able is true.  */
aix-thread.c:	  memcpy (context->gpr, gprs64, sizeof(gprs64));
aix-thread.c:	  memcpy (context->gpr, gprs32, sizeof(gprs32));
aix-thread.c:      	  memcpy (context->fpr, fprs, sizeof(fprs));
aix-thread.c:      	  memcpy (&context->msr, &sprs64, sizeof(sprs64));
aix-thread.c:      	  memcpy (&context->msr, &sprs32, sizeof(sprs32));
aix-thread.c:		     (unsigned long) context->gpr, 0, NULL);
aix-thread.c:	ptrace32 (PTT_WRITE_GPRS, tid, (int *) context->gpr, 0, NULL);
aix-thread.c:      ptrace32 (PTT_WRITE_FPRS, tid, (int *) context->fpr, 0, NULL);
aix-thread.c:		       (unsigned long) &context->msr, 0, NULL);
aix-thread.c:	  ptrace32 (PTT_WRITE_SPRS, tid, (int *) &context->msr, 0, NULL);
alphabsd-nat.c:  t->to_fetch_registers = alphabsd_fetch_inferior_registers;
alphabsd-nat.c:  t->to_store_registers = alphabsd_store_inferior_registers;
alphafbsd-tdep.c:/* Target-dependent code for FreeBSD/alpha.
alpha-linux-tdep.c:/* Target-dependent code for GNU/Linux on Alpha.
alpha-mdebug-tdep.c:/* Target-dependent mdebug code for the ALPHA architecture.
alphanbsd-tdep.c:/* Target-dependent code for NetBSD/alpha.
alphanbsd-tdep.c:   traditional a.out-style core dump format before NetBSD 1.6.  */
alphaobsd-tdep.c:/* Target-dependent code for OpenBSD/alpha.
alpha-osf1-tdep.c:/* Target-dependent code for OSF/1 on Alpha.
alpha-tdep.c:/* Target-dependent code for the ALPHA architecture, for GDB, the GNU Debugger.
alpha-tdep.h:/* Target-dependent structure in gdbarch.  */
amd64bsd-nat.c:  t->to_fetch_registers = amd64bsd_fetch_inferior_registers;
amd64bsd-nat.c:  t->to_store_registers = amd64bsd_store_inferior_registers;
amd64fbsd-nat.c:  t->to_pid_to_exec_file = fbsd_pid_to_exec_file;
amd64fbsd-nat.c:  t->to_find_memory_regions = fbsd_find_memory_regions;
amd64fbsd-nat.c:  t->to_make_corefile_notes = fbsd_make_corefile_notes;
amd64fbsd-tdep.c:/* Target-dependent code for FreeBSD/amd64.
amd64-linux-nat.c:  super_post_startup_inferior = t->to_post_startup_inferior;
amd64-linux-nat.c:  t->to_post_startup_inferior = amd64_linux_child_post_startup_inferior;
amd64-linux-nat.c:  t->to_fetch_registers = amd64_linux_fetch_inferior_registers;
amd64-linux-nat.c:  t->to_store_registers = amd64_linux_store_inferior_registers;
amd64-linux-tdep.c:/* Target-dependent code for GNU/Linux x86-64.
amd64-linux-tdep.h:/* Target-dependent code for GNU/Linux AMD64.
amd64nbsd-tdep.c:/* Target-dependent code for NetBSD/amd64.
amd64obsd-tdep.c:/* Target-dependent code for OpenBSD/amd64.
amd64obsd-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
amd64-sol2-tdep.c:/* Target-dependent code for AMD64 Solaris.
amd64-tdep.c:/* Target-dependent code for AMD64.
amd64-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
amd64-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
amd64-tdep.h:/* Target-dependent definitions for AMD64.
annotate.c:    printf_filtered (("\n\032\032elt-rep %u\n"), repcount);
annotate.c:    printf_filtered (("\n\032\032elt-rep-end\n"));
arch-utils.c:/* Set the dynamic target-system-dependent parameters (architecture,
armbsd-tdep.c:/* Target-dependent code for ARM BSD's.
arm-linux-nat.c:  t->to_fetch_registers = arm_linux_fetch_inferior_registers;
arm-linux-nat.c:  t->to_store_registers = arm_linux_store_inferior_registers;
armnbsd-nat.c:    regcache_raw_supply (current_regcache, regno, (char *) &gregset->r[regno]);
armnbsd-nat.c:		       (char *) &gregset->r_sp);
armnbsd-nat.c:		       (char *) &gregset->r_lr);
armnbsd-nat.c:  r_pc = ADDR_BITS_REMOVE (gregset->r_pc);
armnbsd-nat.c:			 (char *) &gregset->r_cpsr);
armnbsd-nat.c:			 (char *) &gregset->r_pc);
armnbsd-nat.c:			 (char *) &fparegset->fpr[regno - ARM_F0_REGNUM]);
armnbsd-nat.c:		       (char *) &fparegset->fpr_fpsr);
armnbsd-nat.c:  t->to_fetch_registers = armnbsd_fetch_registers;
armnbsd-nat.c:  t->to_store_registers = armnbsd_store_registers;
armnbsd-tdep.c:/* Target-dependent code for NetBSD/arm.
armnbsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-arm-netbsd") == 0)
armobsd-tdep.c:/* Target-dependent code for OpenBSD/arm.
armobsd-tdep.c:  /* OpenBSD/arm uses -fpcc-struct-return by default.  */
arm-tdep.c:	  fprintf_filtered (gdb_stderr, _("Bad bit-field extraction\n"));
arm-tdep.c:	 straight-forward.  Otherwise we have to play around a bit more.  */
arm-tdep.h:  ARM_FLOAT_SOFT_FPA,	/* Traditional soft-float (mixed-endian on LE ARM).  */
arm-tdep.h:  ARM_FLOAT_SOFT_VFP,	/* Soft-float with pure-endian doubles.  */
arm-tdep.h:/* Target-dependent structure in gdbarch.  */
avr-tdep.c:/* Target-dependent code for Atmel AVR, for GDB.
avr-tdep.c:  /* Add 1 here to adjust for the post-decrement nature of the push
avr-tdep.c:   sizes are left-justified within the word (as opposed to arguments smaller
avr-tdep.c:   than WORDSIZE bytes, which are right-justified).
ax-gdb.c:   context-specific interpretations are really just a tool of the
ax-gdb.c:   This should be done (I think) in a post-processing pass, that walks
ax-gdb.c:   starting and one-past-ending *bit* numbers of the field within the
ax-gdb.c:  while (fragment_count-- > 1)
ax.h:       We're assuming eight-bit bytes.  So sue me.
bcache.c:     As a short-circuit first compare the upper part of each hash
bcache.h:   stick eight bytes of text in a bcache, and then stick an eight-byte
bfd-target.c:  bfd_close (t->to_data);
bfd-target.c:  xfree (t->to_sections);
bfd-target.c:  t->to_shortname = "bfd";
bfd-target.c:  t->to_longname = _("BFD backed target");
bfd-target.c:  t->to_doc = _("You should never see this");
bfd-target.c:  t->to_xfer_partial = target_bfd_xfer_partial;
bfd-target.c:  t->to_xclose = target_bfd_xclose;
bfd-target.c:  t->to_data = bfd;
block.c:      bot--;
blockframe.c:      if (endaddr != NULL && !pst->readin)
blockframe.c:      if (pst->readin)
blockframe.c:	  && SYMBOL_VALUE_ADDRESS (msymbol + i) < osect->endaddr)
blockframe.c:	cache_pc_function_high = osect->endaddr;
breakpoint.c:/* Indicator of when exception catchpoints set-up should be
breakpoint.c:   NOTE drow/2003-09-09: This routine could be broken down to an object-style
breakpoint.c:  if (!breakpoint_enabled (bpt->owner))
breakpoint.c:  if (bpt->inserted || bpt->duplicate)
breakpoint.c:  /* Initialize the target-specific information.  */
breakpoint.c:  memset (&bpt->target_info, 0, sizeof (bpt->target_info));
breakpoint.c:  bpt->target_info.placed_address = bpt->address;
breakpoint.c:  if (bpt->loc_type == bp_loc_software_breakpoint
breakpoint.c:      || bpt->loc_type == bp_loc_hardware_breakpoint)
breakpoint.c:	  || bpt->section == NULL
breakpoint.c:	  || !(section_is_overlay (bpt->section)))
breakpoint.c:	  if (bpt->loc_type == bp_loc_hardware_breakpoint)
breakpoint.c:	    val = target_insert_hw_breakpoint (&bpt->target_info);
breakpoint.c:	    val = target_insert_breakpoint (&bpt->target_info);
breakpoint.c:	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
breakpoint.c:			 bpt->owner->number);
breakpoint.c:		  CORE_ADDR addr = overlay_unmapped_address (bpt->address,
breakpoint.c:							     bpt->section);
breakpoint.c:		  bpt->overlay_target_info = bpt->target_info;
breakpoint.c:		  bpt->overlay_target_info.placed_address = addr;
breakpoint.c:		  val = target_insert_breakpoint (&bpt->overlay_target_info);
breakpoint.c:					bpt->owner->number);
breakpoint.c:	  if (section_is_mapped (bpt->section))
breakpoint.c:	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
breakpoint.c:		val = target_insert_hw_breakpoint (&bpt->target_info);
breakpoint.c:		val = target_insert_breakpoint (&bpt->target_info);
breakpoint.c:	      DISABLE_UNSETTABLE_BREAK (bpt->address)
breakpoint.c:	      solib_address (bpt->address)
breakpoint.c:	      bpt->owner->enable_state = bp_shlib_disabled;
breakpoint.c:				      bpt->owner->number);
breakpoint.c:				  "breakpoint #%d\n", bpt->owner->number);
breakpoint.c:	      if (bpt->loc_type == bp_loc_hardware_breakpoint)
breakpoint.c:				      bpt->owner->number);
breakpoint.c:				      bpt->owner->number);
breakpoint.c:		  deprecated_print_address_numeric (bpt->address, 1, tmp_error_stream);
breakpoint.c:	bpt->inserted = 1;
breakpoint.c:  else if (bpt->loc_type == bp_loc_hardware_watchpoint
breakpoint.c:	   && bpt->owner->disposition != disp_del_at_next_stop)
breakpoint.c:      if (bpt->owner->exp_valid_block == NULL)
breakpoint.c:	  fi = frame_find_by_id (bpt->owner->watchpoint_frame);
breakpoint.c:	  v = evaluate_expression (bpt->owner->exp);
breakpoint.c:	  bpt->owner->val_chain = v;
breakpoint.c:	  bpt->inserted = 1;
breakpoint.c:		  if (v == bpt->owner->val_chain
breakpoint.c:		      if (bpt->owner->type == bp_read_watchpoint)
breakpoint.c:		      else if (bpt->owner->type == bp_access_watchpoint)
breakpoint.c:			  bpt->inserted = 0;
breakpoint.c:	  if (!bpt->inserted)
breakpoint.c:				  bpt->owner->number);
breakpoint.c:			   bpt->owner->number);
breakpoint.c:	  if (bpt->owner->related_breakpoint)
breakpoint.c:	    bpt->owner->related_breakpoint->disposition = disp_del_at_next_stop;
breakpoint.c:	  bpt->owner->disposition = disp_del_at_next_stop;
breakpoint.c:  else if (ep_is_exception_catchpoint (bpt->owner))
breakpoint.c:      val = target_insert_breakpoint (&bpt->target_info);
breakpoint.c:			      bpt->owner->number);
breakpoint.c:	  deprecated_print_address_numeric (bpt->address, 1, tmp_error_stream);
breakpoint.c:	  bpt->owner->enable_state = bp_disabled;
breakpoint.c:				      bpt->owner->number);
breakpoint.c:	  args.kind = bpt->owner->type == bp_catch_catch ? 
breakpoint.c:	    bpt->inserted = 1;
breakpoint.c:				  bpt->owner->number);
breakpoint.c:	      bpt->owner->enable_state = bp_disabled;
breakpoint.c:  else if (bpt->owner->type == bp_catch_fork
breakpoint.c:	   || bpt->owner->type == bp_catch_vfork
breakpoint.c:	   || bpt->owner->type == bp_catch_exec)
breakpoint.c:						bpt->owner, RETURN_MASK_ERROR);
breakpoint.c:			 bpt->owner->number);
breakpoint.c:	bpt->owner->enable_state = bp_disabled;
breakpoint.c:	bpt->inserted = 1;
breakpoint.c:       pre-exec() address meaning the same thing in the post-exec()
breakpoint.c:    bpt->inserted = 0;
breakpoint.c:    bpt->inserted = 0;
breakpoint.c:      if (bpt->loc_type != bp_loc_software_breakpoint
breakpoint.c:	  && bpt->loc_type != bp_loc_hardware_breakpoint)
breakpoint.c:      if ((breakpoint_enabled (bpt->owner)
breakpoint.c:	   || bpt->owner->enable_state == bp_permanent)
breakpoint.c:	  && bpt->address == pc)	/* bp is enabled and matches pc */
breakpoint.c:	      && section_is_overlay (bpt->section) 
breakpoint.c:	      && !section_is_mapped (bpt->section))
breakpoint.c:	  else if (bpt->owner->enable_state == bp_permanent)
breakpoint.c:      if (bpt->loc_type != bp_loc_software_breakpoint
breakpoint.c:	  && bpt->loc_type != bp_loc_hardware_breakpoint)
breakpoint.c:      if (bpt->inserted
breakpoint.c:	  && bpt->address == pc)	/* bp is inserted and matches pc */
breakpoint.c:	      && section_is_overlay (bpt->section) 
breakpoint.c:	      && !section_is_mapped (bpt->section))
breakpoint.c:      if (bpt->loc_type != bp_loc_software_breakpoint)
breakpoint.c:      if ((breakpoint_enabled (bpt->owner)
breakpoint.c:	   || bpt->owner->enable_state == bp_permanent)
breakpoint.c:	  && bpt->inserted
breakpoint.c:	  && bpt->address == pc)	/* bp is enabled and matches pc */
breakpoint.c:	      && section_is_overlay (bpt->section) 
breakpoint.c:	      && !section_is_mapped (bpt->section))
breakpoint.c:      if (bpt->loc_type != bp_loc_software_breakpoint
breakpoint.c:	  && bpt->loc_type != bp_loc_hardware_breakpoint)
breakpoint.c:      if ((breakpoint_enabled (bpt->owner)
breakpoint.c:	   || bpt->owner->enable_state == bp_permanent)
breakpoint.c:	  && bpt->address == pc
breakpoint.c:	  && (bpt->owner->thread == -1 || bpt->owner->thread == thread))
breakpoint.c:	      && section_is_overlay (bpt->section) 
breakpoint.c:	      && !section_is_mapped (bpt->section))
breakpoint.c:	  (bsp->breakpoint_at->type == bp_step_resume) &&
breakpoint.c:	  (bsp->breakpoint_at->thread == current_thread || 
breakpoint.c:	   bsp->breakpoint_at->thread == -1))
breakpoint.c:  switch (bs->breakpoint_at->type)
breakpoint.c:      if (bs->breakpoint_at->loc->address != bs->breakpoint_at->loc->requested_address)
breakpoint.c:	breakpoint_adjustment_warning (bs->breakpoint_at->loc->requested_address,
breakpoint.c:	                               bs->breakpoint_at->loc->address,
breakpoint.c:				       bs->breakpoint_at->number, 1);
breakpoint.c:      annotate_breakpoint (bs->breakpoint_at->number);
breakpoint.c:      ui_out_field_int (uiout, "bkptno", bs->breakpoint_at->number);
breakpoint.c:      annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:		       bs->breakpoint_at->number,
breakpoint.c:		       bs->breakpoint_at->triggered_dll_pathname);
breakpoint.c:      annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:		       bs->breakpoint_at->number,
breakpoint.c:		       bs->breakpoint_at->triggered_dll_pathname);
breakpoint.c:      annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:		       bs->breakpoint_at->number, 
breakpoint.c:		       bs->breakpoint_at->forked_inferior_pid);
breakpoint.c:      annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:		       bs->breakpoint_at->number, 
breakpoint.c:		       bs->breakpoint_at->forked_inferior_pid);
breakpoint.c:      annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:		       bs->breakpoint_at->number,
breakpoint.c:		       bs->breakpoint_at->exec_pathname);
breakpoint.c:	  annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:			   bs->breakpoint_at->number);
breakpoint.c:	  annotate_catchpoint (bs->breakpoint_at->number);
breakpoint.c:			   bs->breakpoint_at->number);
breakpoint.c:	  annotate_watchpoint (bs->breakpoint_at->number);
breakpoint.c:	  value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
breakpoint.c:      value_print (bs->breakpoint_at->val, stb->stream, 0, Val_pretty_default);
breakpoint.c:	  annotate_watchpoint (bs->breakpoint_at->number);
breakpoint.c:      value_print (bs->breakpoint_at->val, stb->stream, 0,Val_pretty_default);
breakpoint.c:      if (bs->breakpoint_at != NULL && bs->breakpoint_at->ops != NULL
breakpoint.c:	  && bs->breakpoint_at->ops->print_it != NULL)
breakpoint.c:	return bs->breakpoint_at->ops->print_it (bs->breakpoint_at);
breakpoint.c:      struct value *new_val = evaluate_expression (bs->breakpoint_at->exp);
breakpoint.c:      ui_out_field_int (uiout, "wpnum", bs->breakpoint_at->number);
breakpoint.c:	b->related_breakpoint->disposition = disp_del_at_next_stop;
breakpoint.c:	      b->related_breakpoint->disposition = disp_del_at_next_stop;
breakpoint.c:		  b->related_breakpoint->disposition = disp_del_at_next_stop;
breakpoint.c:	    b->ignore_count--;
breakpoint.c:      (bs->breakpoint_at->type == bp_hardware_watchpoint ||
breakpoint.c:       bs->breakpoint_at->type == bp_read_watchpoint ||
breakpoint.c:       bs->breakpoint_at->type == bp_access_watchpoint))
breakpoint.c:      switch (bs->breakpoint_at->type)
breakpoint.c:	     step-out-of-dld behaviour.  Otherwise, we ignore this
breakpoint.c:    if (breakpoint_enabled (bpt->owner)
breakpoint.c:	&& bpt->inserted
breakpoint.c:	&& bpt->loc_type == bp_loc_hardware_watchpoint)
breakpoint.c:  for (; ep_list != NULL; ep_list = ep_list->next)
breakpoint.c:      ep = ep_list->breakpoint_at;
breakpoint.c:  enum bptype type = bpt->type;
breakpoint.c:  CORE_ADDR address = bpt->loc->address;
breakpoint.c:  asection *section = bpt->loc->section;
breakpoint.c:  /* Set language, input-radix, then reissue breakpoint command. 
breakpoint.c:     Ensure the language and input-radix are restored afterwards.  */
breakpoint.c:	  scope_breakpoint->enable_state = bp_enabled;
breakpoint.c:	  scope_breakpoint->disposition = disp_del;
breakpoint.c:	  scope_breakpoint->frame_id = get_frame_id (prev_frame);
breakpoint.c:	  scope_breakpoint->loc->requested_address
breakpoint.c:	  scope_breakpoint->loc->address
breakpoint.c:	    = adjust_breakpoint_address (scope_breakpoint->loc->requested_address,
breakpoint.c:	                                 scope_breakpoint->type);
breakpoint.c:    if (bs->breakpoint_at && bs->breakpoint_at->disposition == disp_del
breakpoint.c:  if (bpt->type == bp_none)
breakpoint.c:  breakpoint_delete_event (bpt->number);
breakpoint.c:  if (bpt->loc->inserted)
breakpoint.c:    remove_breakpoint (bpt->loc, mark_inserted);
breakpoint.c:  free_valchain (bpt->loc);
breakpoint.c:    breakpoint_chain = bpt->next;
breakpoint.c:  if (bp_location_chain == bpt->loc)
breakpoint.c:    bp_location_chain = bpt->loc->next;
breakpoint.c:				  bpt->number);
breakpoint.c:      args.kind = bpt->type == bp_catch_catch ? 
breakpoint.c:      b->next = bpt->next;
breakpoint.c:    if (loc->next == bpt->loc)
breakpoint.c:	loc->next = bpt->loc->next;
breakpoint.c:  if (bpt->loc->inserted
breakpoint.c:      && bpt->type != bp_hardware_watchpoint
breakpoint.c:      && bpt->type != bp_read_watchpoint
breakpoint.c:      && bpt->type != bp_access_watchpoint
breakpoint.c:      && bpt->type != bp_catch_fork
breakpoint.c:      && bpt->type != bp_catch_vfork
breakpoint.c:      && bpt->type != bp_catch_exec)
breakpoint.c:	if (b->loc->address == bpt->loc->address
breakpoint.c:	    && b->loc->section == bpt->loc->section
breakpoint.c:  free_command_lines (&bpt->commands);
breakpoint.c:  if (bpt->cond)
breakpoint.c:    xfree (bpt->cond);
breakpoint.c:  if (bpt->cond_string != NULL)
breakpoint.c:    xfree (bpt->cond_string);
breakpoint.c:  if (bpt->addr_string != NULL)
breakpoint.c:    xfree (bpt->addr_string);
breakpoint.c:  if (bpt->exp != NULL)
breakpoint.c:    xfree (bpt->exp);
breakpoint.c:  if (bpt->exp_string != NULL)
breakpoint.c:    xfree (bpt->exp_string);
breakpoint.c:  if (bpt->val != NULL)
breakpoint.c:    value_free (bpt->val);
breakpoint.c:  if (bpt->source_file != NULL)
breakpoint.c:    xfree (bpt->source_file);
breakpoint.c:  if (bpt->dll_pathname != NULL)
breakpoint.c:    xfree (bpt->dll_pathname);
breakpoint.c:  if (bpt->triggered_dll_pathname != NULL)
breakpoint.c:    xfree (bpt->triggered_dll_pathname);
breakpoint.c:  if (bpt->exec_pathname != NULL)
breakpoint.c:    xfree (bpt->exec_pathname);
breakpoint.c:  bpt->type = bp_none;
breakpoint.c:  xfree (bpt->loc);
breakpoint.c:  if (bpt->type == bp_watchpoint_scope)
breakpoint.c:  if (bpt->enable_state == bp_permanent)
breakpoint.c:  bpt->enable_state = bp_disabled;
breakpoint.c:  breakpoint_modify_event (bpt->number);
breakpoint.c:      switch (bpt->type)
breakpoint.c:		 bpt->number);
breakpoint.c:  if (bpt->type == bp_hardware_breakpoint)
breakpoint.c:  if (bpt->pending)
breakpoint.c:      if (bpt->enable_state != bp_enabled)
breakpoint.c:	  bpt->enable_state = bp_enabled;
breakpoint.c:	  bpt->disposition = disposition;
breakpoint.c:      if (bpt->enable_state != bp_permanent)
breakpoint.c:	bpt->enable_state = bp_enabled;
breakpoint.c:      bpt->disposition = disposition;
breakpoint.c:      if (bpt->type == bp_watchpoint || 
breakpoint.c:	  bpt->type == bp_hardware_watchpoint ||
breakpoint.c:	  bpt->type == bp_read_watchpoint || 
breakpoint.c:	  bpt->type == bp_access_watchpoint)
breakpoint.c:	  if (bpt->exp_valid_block != NULL)
breakpoint.c:		fr = frame_find_by_id (bpt->watchpoint_frame);
breakpoint.c:is valid is not currently in scope.\n"), bpt->number);
breakpoint.c:		  bpt->enable_state = bp_disabled;
breakpoint.c:	  value_free (bpt->val);
breakpoint.c:	  bpt->val = evaluate_expression (bpt->exp);
breakpoint.c:	  release_value (bpt->val);
breakpoint.c:	  if (value_lazy (bpt->val))
breakpoint.c:	    value_fetch_lazy (bpt->val);
breakpoint.c:	  if (bpt->type == bp_hardware_watchpoint ||
breakpoint.c:	      bpt->type == bp_read_watchpoint ||
breakpoint.c:	      bpt->type == bp_access_watchpoint)
breakpoint.c:	      int i = hw_watchpoint_used_count (bpt->type, &other_type_used);
breakpoint.c:	      int mem_cnt = can_use_hardware_watchpoint (bpt->val);
breakpoint.c:									bpt->type, i + mem_cnt, other_type_used);
breakpoint.c:have been allocated for other watchpoints.\n"), bpt->number);
breakpoint.c:		  bpt->enable_state = bp_disabled;
breakpoint.c:  breakpoint_modify_event (bpt->number);
breakpoint.c:  do_enable_breakpoint (bpt, bpt->disposition);
breakpoint.c:      switch (bpt->type)
breakpoint.c:		 bpt->number);
breakpoint.c:  bp_tgt->placed_address = pc;
breakpoint.c:Configure various breakpoint-specific variables such as\n\
breakpoint.c:Configure various breakpoint-specific variables such as\n\
breakpoint.h:/* FIXME In the future, we should fold all other breakpoint-like things into
breakpoint.h:   with it, which represent target-specific and machine-specific
breakpoint.h:/* Prototypes for breakpoint-related functions.  */
breakpoint.h:   breakpoints.  These functions are used in murky target-specific
breakpoint.h:/* Indicator of when exception catchpoints set-up should be
bsd-uthread.c:  t->to_shortname = "bsd-uthreads";
bsd-uthread.c:  t->to_longname = "BSD user-level threads";
bsd-uthread.c:  t->to_doc = "BSD user-level threads";
bsd-uthread.c:  t->to_mourn_inferior = bsd_uthread_mourn_inferior;
bsd-uthread.c:  t->to_fetch_registers = bsd_uthread_fetch_registers;
bsd-uthread.c:  t->to_store_registers = bsd_uthread_store_registers;
bsd-uthread.c:  t->to_xfer_partial = bsd_uthread_xfer_partial;
bsd-uthread.c:  t->to_wait = bsd_uthread_wait;
bsd-uthread.c:  t->to_resume = bsd_uthread_resume;
bsd-uthread.c:  t->to_thread_alive = bsd_uthread_thread_alive;
bsd-uthread.c:  t->to_find_new_threads = bsd_uthread_find_new_threads;
bsd-uthread.c:  t->to_extra_thread_info = bsd_uthread_extra_thread_info;
bsd-uthread.c:  t->to_pid_to_str = bsd_uthread_pid_to_str;
bsd-uthread.c:  t->to_stratum = thread_stratum;
bsd-uthread.c:  t->to_magic = OPS_MAGIC;
buildsym.c:      for (j = list->nsyms; --j >= 0;)
buildsym.c:	  pp = DEPRECATED_SYMBOL_NAME (list->symbol[j]);
buildsym.c:	      return (list->symbol[j]);
buildsym.c:      list = list->next;
buildsym.c:      next1 = next->next;
buildsym.c:      next1 = next->next;
buildsym.c:      next1 = next->next;
buildsym.c:      bnext1 = bnext->next;
buildsym.c:      next1 = next->next;
buildsym.c:      next->next = free_pendings;
buildsym.c:  for (next = pending_blocks, i = 0; next; next = next->next, i++)
buildsym.c:  for (next = pending_blocks; next; next = next->next)
buildsym.c:      BLOCKVECTOR_BLOCK (blockvector, --i) = next->block;
buildsym.c:      next1 = next->next;
buildsym.c:      subfile->language = subfile->next->language;
buildsym.c:      && (subfile->next->language == language_cplus
buildsym.c:	  || subfile->next->language == language_fortran))
buildsym.c:      subfile->language = subfile->next->language;
buildsym.c:	  subfile->language = subfile->next->language;
buildsym.c:	      if (BLOCK_START (pb->block) < BLOCK_START (pbnext->block))
buildsym.c:		  pb->block = pbnext->block;
buildsym.c:		  pbnext->block = tmp;
buildsym.c:	      pbnext = pbnext->next;
c-exp.c:   if the built-in stack extension method is used).
c-exp.c:			  while (count-- > 0)
c-exp.y:			  while (count-- > 0)
ChangeLog:	* event-top.c (command_handler): On EOF, print 'quit' and run quit
ChangeLog:	* Makefile.in (SFILES): Add target-memory.c.
ChangeLog:	(COMMON_OBS): Add target-memory.o.
ChangeLog:	* target-memory.c: New file.
ChangeLog:	(mem_info_command): Handle target-supplied regions and flash
ChangeLog:	Keep gdb-done-regexp for partial-output-buffer.
ChangeLog:	(gdb-stack-list-frames-handler): Add face to function names.
ChangeLog:	* NEWS: Mention "set trust-readonly-sections" fix.
ChangeLog:	* event-top.c (display_gdb_prompt): Call reset_command_nest_depth.
ChangeLog:	a.out-style core file format here.  Make global.
ChangeLog:	Update the target-specific state if necessary.
ChangeLog:	* mt-tdep.c (mt_register_name): Correct out-of-range logic to
ChangeLog:	* mt-tdep.c (mt_gdb_regnums): Add ZI2, ZQ2, Ichannel2,
ChangeLog:	* mt-tdep.c (mt_gdb_regnums): Define
ChangeLog:	* linux-nat.c (linux_nat_wait): Do not short-cut reporting
ChangeLog:	(value_of_internalvar): Flip the endian of built-in types if required.
ChangeLog:	(gdb-break-list-regexp, gdb-stack-list-frames-regexp): 
ChangeLog:	(gdbmi-prompt2, gdb-break-list-handler,gdb-get-source-file)
ChangeLog:	gdb-get-buffer-create.
ChangeLog:	(gdbmi-frame-handler): Use hollow-right-triangle for all selected
ChangeLog:	* event-top.c (async_do_nothing, async_disconnect)
ChangeLog:	(gdb-break-list-regexp): Match "what" field if present.
ChangeLog:	(gdb-stack-list-frames-regexp): Match "from" field if present.
ChangeLog:	(gdb-stack-list-frames-handler): Present output like "info
ChangeLog:	(event-loop.o, inflow.o, mingw-hdep.o, posix-hdep.o, ser-base.o)
ChangeLog:	* event-loop.c: Include "gdb_select.h".
ChangeLog:	event-loop.c.  Add exception condition support.  Use serial_for_fd
ChangeLog:	* mt-tdep.c (enum mt_gdb_regnums): Add MT_COPRO_PSEUDOREG_ARRAY,
ChangeLog:	* event-loop.c (gdb_select): Detect file descriptors that have
ChangeLog:left-margin: 8
ChangeLog-1990:	format-dependent function that knows how to read it in.  Make
ChangeLog-1990:	the format-specific part from the format-independent part,
ChangeLog-1990:	leaving the format-independent part such as file name expansion
ChangeLog-1990:	generic and object-file-specific symbol reading code.
ChangeLog-1990:	Added PUSH_ARGUMENTS macro to support funny argument-pushing
ChangeLog-1990:	  occurs in mid-input-line before newline.  This allows
ChangeLog-1990:	* Split default-dep.c into infptrace.c and execcore.c.
ChangeLog-1990:	(gdb.tar): Use gdb-$(VERSION), not dist-gdb.
ChangeLog-1990:	* default-dep.c (read_inferior_memory): Check quit_flag in
ChangeLog-1990:left-margin: 8
ChangeLog-1991:	* config/mt-amix, config/mt-i386v4:  Add solib.o to TDEPFILES
ChangeLog-1991:	array type whose element-type size isn't immediately known.
ChangeLog-1991:	* config/mh-i386v4, config/mt-i386v4, tm-i386v4.h, xm-i386v4.h:
ChangeLog-1991:	* configure.in:  Handle i386-none-aout rather than i386-aout-none.
ChangeLog-1991:	gdb/config/mh-* and gdb/config/mt-*.  This is for consistency with
ChangeLog-1991:	setting pst->texthigh.
ChangeLog-1991:                    so they are built-in.  Sort of a hack.
ChangeLog-1991:     m2-exp.y       Added the built-in procedures INC, INCL, DEC, and DECL to
ChangeLog-1991:	makeinfo'ing and TeXing; also ensured gdb-all.texinfo (post-m4) 
ChangeLog-1991:	and gdb.info (post- texinfo2 makeinfo) generated for distribution.
ChangeLog-1991:	to properly set pst->symtab; avoid searching for it.
ChangeLog-1991:	(psymtab_to_symtab_1):  Set pst->symtab.
ChangeLog-1991:	* sparc-tdep.c:  Avoid including lots of Sun-host-specific files.
ChangeLog-1991:	single_step() in a target-independent fashion.
ChangeLog-1991:	* dbxread.c (end_psymtab): Initialize pst->symtab.
ChangeLog-1991:	asm-demangle" and "set sevenbit-strings" to "set print
ChangeLog-1991:	sevenbit-strings".
ChangeLog-1991:	(add_target): Call add_cmd and mess with targetlist->doc.
ChangeLog-1991:	for printing the float info is host-dependent, not
ChangeLog-1991:	target-dependent.  FIXME.
ChangeLog-1991:	pst->filename.  Good, since that hack confused code in symfile.c!
ChangeLog-1991:	"set screen-height" => "set height"; add sevenbit-strings.
ChangeLog-1991:left-margin: 8
ChangeLog-1992:	* nindy-share/stop.h: fixed bogus comment-end in copyright message
ChangeLog-1992:	* partial-stab.h ('f', 'F'):  Don't reference pst->textlow if pst
ChangeLog-1992:	* mipsread.c (UNSAFE_DATA_ADDR):  Remove MIPS-host-specific
ChangeLog-1992:	* config/irix3.mh (NATDEPFILES):  nat-mips.o => mips-nat.o.
ChangeLog-1992:	remote-adapt.c (adapt-ops),
ChangeLog-1992:	values.  And otherwise fix the relevant bit-rotted code.
ChangeLog-1992:	* nat-sparc.c -> sparc-nat.c
ChangeLog-1992:	* nat-sun4os4.h -> nm-sun4os4.h
ChangeLog-1992:	* nat-trash.h -> nm-trash.h
ChangeLog-1992:	* nat-trash.h: temporary header file.  This should be removed once
ChangeLog-1992:	* configure.in: add a symlink from nat-trash.h to nat.h if no
ChangeLog-1992:	* sparc-xdep.c: removed.  contents have been moved to nat-sparc.c.
ChangeLog-1992:	  nat-sun4os4.h.
ChangeLog-1992:	* nat-sparc.c, nat-sun4os4.h: new files for sun4 native support.
ChangeLog-1992:	Make the /proc support a target-struct in its own right.
ChangeLog-1992:	Split non-target-dependent code out of target_attach routines.
ChangeLog-1992:	here; it is dealt with at a gdb-target-independent level.
ChangeLog-1992:	* tm-rs6000.h (ATTACH_DETACH):  Remove: host-dependent.
ChangeLog-1992:	(PTRACE_ATTACH, PTRACE_DETACH):  Remove: host-dep.
ChangeLog-1992:	(NO_SINGLE_STEP):  Add, target-dependent.
ChangeLog-1992:	(NO_SINGLE_STEP):  Remove, target-dependent.
ChangeLog-1992:	* Makefile.in (VERSION):  Bump to 4.6.1 (post-release versions).
ChangeLog-1992:	maintenance print-type command.
ChangeLog-1992:	* procfs.c (proc_set_exec_trap): Set run-on-last-close flag on
ChangeLog-1992:	in an objfile, and zaps the start-of-chain pointer.
ChangeLog-1992:	in all lower layers of symbol reading.  Call format-specific
ChangeLog-1992:	* symfile.c:  Add almost-OK debug versions of add_psymbol_*to_list.
ChangeLog-1992:	turn off trace inherit-on-fork flag to favor latest SVR4 method.
ChangeLog-1992:	inherit-on-fork flag, moved to proc_set_exec_trap().
ChangeLog-1992:	to reset inherit-on-fork flag, bash comment to GNU form.
ChangeLog-1992:	* procfs.c (open_proc_file):  Disable inherit-on-fork flag so that
ChangeLog-1992:	* config/mt-*mips:  Remove ecoff.o from the configuration.
ChangeLog-1992:	gdb/xm-irix4.h gdb/config/mt-irix3
ChangeLog-1992:	* Makefile.in:  Move place where configure merges in host-
ChangeLog-1992:	and target-dependent fragments later, so the latter
ChangeLog-1992:	* config/mt-bigmips, config/mt-littlemips:  Add ecoff.o.
ChangeLog-1992:	* config/mh-stratus, config/mt-stratus, tm-stratus.h, xm-stratus.h:
ChangeLog-1992:left-margin: 8
ChangeLog-1993:	visibility character, just shove it in fip->list->visibility.
ChangeLog-1993:	* blockframe.c (find_pc_partial_function): If pst->readin is
ChangeLog-1993:	* mipsread.c (parse_type):  Alpha cc now supports the t->continued
ChangeLog-1993:	"retransmit-timeout" variables to set mips_receive_wait and
ChangeLog-1993:	->next->frame and is an artifact from GDB 2.8.
ChangeLog-1993:	* utils.c (quit): Use current_target->to_terminal_ours to figure
ChangeLog-1993:	* configure.in (mips-idt-ecoffl*): New target; use idtl.
ChangeLog-1993:	(mips-idt-ecoff*): Added trailing '*'.
ChangeLog-1993:	infrun.c: Replace switch (stop_bpstat->breakpoint_at->type)
ChangeLog-1993:	* m88k-nat-c (SXIP_OFFSET, SNIP_OFFSET, SFIP_OFFSET):  Enclose
ChangeLog-1993:	enums, don't assume that they are int-sized.
ChangeLog-1993:	* configure.in (mips-idt-ecoff): New target; uses idt.mt.
ChangeLog-1993:left-margin: 8
ChangeLog-1994:	"mips*-idt-ecoff*" so it'll work for the LSI33k.
ChangeLog-1994:	changes.  They are correct, unlike the post-Nov 3 comment
ChangeLog-1994:	* objfiles.h (struct objfile): Fix comment--minimal_symbol_count
ChangeLog-1994:	list-objfiles to make this clear.  Comment out all of
ChangeLog-1994:	list-objfiles because old gdb's choke on it.
ChangeLog-1994:	* .gdbinit: Add list-objfiles command.
ChangeLog-1994:	* mdebugread.c (psymtab_to_symtab_1):  Use pst->textlow for the
ChangeLog-1994:	instead of section_offsets and use relocated pst->textlow for
ChangeLog-1994:	(prompt_for_continue): Likewise for prompt-for-continue annotation.
ChangeLog-1994:	* configure.in: Recognize i[34]86-sequent-sysv4* host.
ChangeLog-1994:	(REGISTER_NAMES): Add entries for "right-half" of FP registers.
ChangeLog-1994:	* printcmd.c: Remove "set print fast-symbolic-addr off" command.
ChangeLog-1994:	* printcmd.c (print_address_symbolic): If set print fast-symbolic-addr
ChangeLog-1994:	fast-symbolic-addr' and default it to fast (the old way).
ChangeLog-1994:left-margin: 8
ChangeLog-1995:	* tm-hppa.h (STORE_RETURN_VALUE): Fix to work with -msoft-float
ChangeLog-1995:	* configure.in (m68*-est-*): Use monitor target config.
ChangeLog-1995:	* .gdbinit: Move list-objfiles to gdb.gdb.
ChangeLog-1995:	(init-new.c): New target, attempt to generate init.c from sources.
ChangeLog-1995:	SOFUN_ADDRESS_MAYBE_MISSING case by passing pst->filename
ChangeLog-1995:	* configure.in:  Move test for m68*-est-* before m68*-*-coff*.
ChangeLog-1995:	instead of getting pst->textlow from the stab.
ChangeLog-1995:left-margin: 8
ChangeLog-1996:	* sparclet-rom.c: Remove includes of Unix system files.
ChangeLog-1996:	* sparclet-stub.c: New -- remote protocol support for sparclet CPU.
ChangeLog-1996:	psymtab and symtab reading, passed via pst->read_symtab_private.
ChangeLog-1996:	Allocate and initialize pst->read_symtab_private.
ChangeLog-1996:	Relocate pst->textlow and pst->texthigh with baseaddr.
ChangeLog-1996:	pst->read_symtab_private, set cu_header_offset and baseaddr.
ChangeLog-1996:	* blockframe.c: Add target-independant support for managing
ChangeLog-1996:  	* sparclet-rom.c, config/sparc/sparclet.mt,
ChangeLog-1996:	notify target-dependent code about new symbol tables.
ChangeLog-1996:	* breakpoint.c (delete_breakpoint):  Fix bpt->val, bpt->exp
ChangeLog-1996:	(add_task_commands): Add new port-right info commands.
ChangeLog-1996:	pst->textlow if the function symbol value is zero. 
ChangeLog-1996:	* configure.in (sparclet-*-aout*): New config.
ChangeLog-1996:	(mips_send_packet): Scan out-of-sequence packets.
ChangeLog-1996:left-margin: 8
ChangeLog-1997:	and current-function so that tfind behaves like stepping (only
ChangeLog-1997:	to 30 bits in call insn to handle --enable-64-bit-bfd.
ChangeLog-1997:	(STORE_STRUCT_RETURN): Change to handle --enable-64-bit-bfd.
ChangeLog-1997: 	target-specific flag bits from PC, for more aesthetic disassembly.
ChangeLog-1997:	in a target-specific file instead (such as ppc-bdm.c in the case
ChangeLog-1997:	making this file less target-specific.
ChangeLog-1997:	* mips-tdep.c (mips_push_arguments): don't left-adjust 32-bit
ChangeLog-1997:	* sparclet-rom.c: Ditto.
ChangeLog-1997:	* sparclet-rom.c:  Disembowel.  Leave only download routine.
ChangeLog-1997:	lousy out-of-date clone of remote.c.
ChangeLog-1997:	are using gcc when using the -export-dynamic option.  Fixes a
ChangeLog-1997:left-margin: 8
ChangeLog-1998: 	work. For, non-hpux, t->to_core_file_to_sym_file does not have a
ChangeLog-1998:	(hpread_lookup_type): Initially allocate a correct-size type-vector.
ChangeLog-1998:	bad interaction between start-up-with-shell and the HP
ChangeLog-1998:	* mips-tdep.c (mips_push_arguments): Don't left-shift small
ChangeLog-1998:        essential to debugging, -fno-omit-frame-pointer
ChangeLog-1998:	(sparc_store_return_value): Right-justify the return value before
ChangeLog-1998:        and used if alternate wait-filter has not been provided.
ChangeLog-1998:        * sparclet-rom.c (_initialize_sparclet, init_sparclet_cmds): Ditto.
ChangeLog-1998: 	with subtarget-specific `mach', rather than fixed default.
ChangeLog-1998:	* configure.in (CONFIG_LDFLAGS): Only add -export-dynamic
ChangeLog-1998:left-margin: 8
ChangeLog-1999:	* event-loop.c (handle_timer_event): When calling the timer
ChangeLog-1999: 	memory-read-packet-size'' and ``set remote
ChangeLog-1999: 	memory-write-packet-size''.  Deprecate ``set remotepacketsize''.
ChangeLog-1999:	* event-loop.c (gdb_do_one_event): Delete SET_TOP_LEVEL call.
ChangeLog-1999:	* Makefile.in (event-top.o): Add dependency on target.h.
ChangeLog-1999:	* event-top.c: Make dependency on target.h explicit.
ChangeLog-1999:	(builtin_type_v4sf): New built-in type.
ChangeLog-1999:	* infcmd.c: Remove include of event-loop.h.
ChangeLog-1999:	Remove includes of event-top.h and event-loop.h. Add include of
ChangeLog-1999:	* event-top.h: Don't use gdb_client_data, use void*, to avoid
ChangeLog-1999: 	dependency on event-loop.h.
ChangeLog-1999:	* event-top.c (stdin_event_handler): Delete fd parameter, use
ChangeLog-1999:	* event-top.h (stdin_event_handler): Delete fd parameter.
ChangeLog-1999:	* event-loop.h (handler_func): Delete fd parameter.
ChangeLog-1999:	* event-loop.c (handle_file_event): Delete fd param from call to
ChangeLog-1999:	* event-loop.c (inferior_event_handler,
ChangeLog-1999:	* event-loop.h (inferior_event_handler): Move from here.
ChangeLog-1999:	* event-top.c (async_stop_sig): Use sigprocmask when available.  
ChangeLog-1999:	* event-loop.c (poll_timers): Check whether the timer list has any
ChangeLog-1999:	* event-top.c (async_disable_stdin): Don't add
ChangeLog-1999:	* breakpoint.c, defs.h, event-top.c, infcmd.c, infrun.c, main.c,
ChangeLog-1999:	* event-top.c, infrun.c: No longer need to include "remote.h".
ChangeLog-1999:	* Makefile.in (event-top.o): Delete dependency on "remote.h".
ChangeLog-1999:	* event-top.c (async_disable_stdin, async_disable_stdin): Use
ChangeLog-1999: 	(return_to_top_level, execute_command), event-top.c
ChangeLog-1999:	* infcmd.c: Include "event-top.h".
ChangeLog-1999:	* event-top.c (async_disable_stdin, async_enable_stdin): To
ChangeLog-1999:	* Makefile.in (event-top.o): Add dependency.
ChangeLog-1999:	* event-top.c: Include "remote.h".
ChangeLog-1999:	* remote.c (async_interrupt_query), event-top.c:
ChangeLog-1999: 	(cleanup_sigint_signal_handler), event-top.c (async_enable_stdin),
ChangeLog-1999: 	event-top.h (async_enable_stdin): Change signature to match
ChangeLog-1999:	* event-top.c (async_enable_stdin): New function. Reinstate stdin
ChangeLog-1999:	* event-top.h (async_enable_stdin): Export.
ChangeLog-1999:	* event-loop.c (fetch_inferior_event_wrapper): New
ChangeLog-1999:	* event-loop.c (poll_timers): Use correct timeval field names,
ChangeLog-1999:	* event-loop.c, event-top.c, event-loop.h: Rerun indent.
ChangeLog-1999:	* event-loop.c: Include <sys/time.h>.
ChangeLog-1999:	* event-top.c (change_line_handler): Cleanup dead code. Add comments.
ChangeLog-1999:	* event-loop.c: Cleanup #if 0 code.
ChangeLog-1999:	* event-loop.h (timer_handler_func): New function type.
ChangeLog-1999:	* event-loop.c: Add timeout and timeout_valid fields to
ChangeLog-1999:	* event-top.c (rl_callback_read_char_wrapper): Ditto.
ChangeLog-1999:	* event-top.h (stdin_event_handler): Export new function.
ChangeLog-1999:	* event-top.c (stdin_event_handler): New function. Smarter handler
ChangeLog-1999:	* event-loop.h: (handler_func): Change signature, adding two new
ChangeLog-1999:	* event-loop.c: Include "inferior.h".
ChangeLog-1999: 	every file that includes event-top.h.
ChangeLog-1999:	* ser-unix.c: Include "event-loop.h".
ChangeLog-1999:	* event-loop.c (create_file_handler): Increment the total number
ChangeLog-1999:	* event-top.c (call_readline): Change to accept gdb_client_data as
ChangeLog-1999:	* event-top.h (call_readline, gdb_readline2): Change accordingly.
ChangeLog-1999:	* event-loop.c (add_file_handler): Change 2nd par to
ChangeLog-1999:	* event-loop.h (create_async_signal_handler): Change accordingly.
ChangeLog-1999:	* event-top.h: New file. All the exported vars and functions from
ChangeLog-1999: 	event-top.c.
ChangeLog-1999:	* event-loop.h (struct gdb_event, event_handler_func,
ChangeLog-1999: 	FD_SETSIZE, howmany, NFDBITS, MASK_SIZE): Move to event-loop.c.
ChangeLog-1999: 	call_readline, input_handler, input_fd): Move to event-top.h.
ChangeLog-1999:	* event-loop.c: (struct gdb_event, event_handler_func,
ChangeLog-1999: 	event-loop.h.
ChangeLog-1999:	Include event-top.h. Remove use of PARAMS. ANSIfy functions headers.
ChangeLog-1999:	* event-top.c: Include event-top.h. Include "signals.h", not
ChangeLog-1999:	(handle_stop_sig): move prototype to event-top.h.
ChangeLog-1999:	* remote.c: Include event-top.h. Make it understand
ChangeLog-1999:	* infrun.c: Include event-top.h.
ChangeLog-1999:	* event-loop.c (create_file_event): New function. Creates a gdb
ChangeLog-1999:	* event-loop.h: export create_file_event().
ChangeLog-1999:	* event-loop.c (delete_file_handler): Move the clearing of the
ChangeLog-1999:	sparcl-stub.c, sparclet-stub.c (remcomInBuffer, remcomOutBuffer):
ChangeLog-1999:	* i387-tdep.c (print_387_control_word): Break out bit-splitting into...
ChangeLog-1999:	(print_387_status_word): Break out bit-splitting into...
ChangeLog-1999:	* event-top.c: Include handle_sigwinch() function prototype within
ChangeLog-1999: 	sparcl-stub.c, sparclet-stub.c (getpacket): Remove 'buffer' arg,
ChangeLog-1999:	* sparc-stub.c, sparcl-stub.c, sparclet-stub.c (handle_exception):
ChangeLog-1999:	* utils.c: #include "event-loop.h" for declaration of
ChangeLog-1999:	* Makefile.in (utils.o): Add dependency on event-loop.h.
ChangeLog-1999:	* event-top.c (mark_async_signal_handler_wrapper,
ChangeLog-1999:	* event-loop.h: To here.
ChangeLog-1999:	* event-top.c: #include "gdbcmd.h" which includes "command.h" and
ChangeLog-1999: 	event-top.c (ISATTY): Move definitions from here.
ChangeLog-1999:	sparc-stub, sparcl-stub.c sparclet-stub.c (getpacket): If '$',
ChangeLog-1999: 	sparcl-stub.c sparclet-stub.c (getpacket): Changed to return ptr
ChangeLog-1999:	* event-loop.h: Export exec_done_display_p.
ChangeLog-1999:	* event-top.c: New variable exec_done_display_p.
ChangeLog-1999: 	sparclet-stub.c (set_debug_traps): Don't send gratuitous ACK.
ChangeLog-1999:	enable print-out depending on an environment variable GDB_SHOW_DR.
ChangeLog-1999:	* event-loop.c (gdb_wait_for_event): Before going to wait for
ChangeLog-1999:	* event-top.c (gdb_readline2): Do not buffer the input, because
ChangeLog-1999:	* event-top.c (change_line_handler): Ditto.
ChangeLog-1999:	* event-loop.c (add_file_handler): Change proc parameter to be ptr
ChangeLog-1999:	* event-loop.h: Get rid of typedefs for file_handler_func and
ChangeLog-1999:	* event-top.c (command_line_handler): Don't treat an empty line
ChangeLog-1999: 	is in state unsupported or support-unknown.
ChangeLog-1999:	* event-loop.c: Fix typo in comment.
ChangeLog-1999:	* event-top.c (display_gdb_prompt): Don't do anything if we are
ChangeLog-1999:	* event-top.c (display_gdb_prompt): Don't display the prompt if we
ChangeLog-1999: 	remote-mips64-transfers-32bit-regs'' that provides backward
ChangeLog-1999:	* event-top.c (command_handler): Set up for a continuation, if we
ChangeLog-1999:	* remote.c: Include event-loop.h.
ChangeLog-1999:	* infrun.c: Include "event-loop.h".
ChangeLog-1999:	* event-top.c (push_prompt): Make non static.
ChangeLog-1999:	* event-loop.c (delete_async_signal_handler): Pass a pointer to a
ChangeLog-1999:	* event-loop.h: Add push_prompt, pop_prompt, handle_sigint to the
ChangeLog-1999:	* Makefile.in (infrun.o): Add dependency on event-loop.h.
ChangeLog-1999:	* event-loop.c (gdb_do_one_event): Make static.
ChangeLog-1999:	* event-top.c (cli_command_loop): New name for start_event_loop().
ChangeLog-1999:	* event-loop.h: Adjust exported functions accordingly.
ChangeLog-1999:	* event-top.c (_initialize_event_loop): To here.
ChangeLog-1999:	* event-top.c (change_line_handler): Get rid of the global
ChangeLog-1999:	* event-loop.c (add_file_handler): New function. Wrapper for
ChangeLog-1999:	* event-top.c (_initialize_event_loop): Call add_file_handler,
ChangeLog-1999:	* event-loop.h: Export add_file_handler instead of
ChangeLog-1999:	* top.c: Move include of event-loop.h, to avoid redefinition of
ChangeLog-1999:	* event-loop.c (create_file_handler): Do not do a realloc of the
ChangeLog-1999:	* event-top.c: Fix prototype for _initialize_event_loop.
ChangeLog-1999:	(event-loop.o): Add dependencies on top.h and defs.h.
ChangeLog-1999:	(event-top.o): Add dependency on terminal.h.
ChangeLog-1999:	* event-loop.c: Get rid of #include <readline.h>.
ChangeLog-1999:	* event-loop.h: Get rid of nested #include's. 
ChangeLog-1999:	* event-loop.c: Rearrange includes to accomodate change in
ChangeLog-1999: 	event-loop.h. Include poll.h, not sys/poll.h.
ChangeLog-1999:	* event-top.c: Ditto.
ChangeLog-1999:	* cli-out.c (cli_out_new): Add flags argument to ui-out-new call.
ChangeLog-1999:	* event-top.c (start_event_loop): call get_prompt.
ChangeLog-1999:	* event-loop.c (delete_file_handler): When positioning prev_ptr,
ChangeLog-1999:	command "set prompt-escape-char" to set gdb_prompt_escape.
ChangeLog-1999:	* event-top.c (setup_event_loop): Change name to start_event_loop.
ChangeLog-1999:  	Move the intialization of event-loop variables to
ChangeLog-1999: 	set up important event-loop variables.
ChangeLog-1999:	* event-loop.h: setup_event_loop is now start_event_loop.
ChangeLog-1999:	* event-top.c (gdb_readline2): Call the command handling function
ChangeLog-1999: 	use of event-top.c.
ChangeLog-1999:	* event-top.c: Include top.h and terminal.h.
ChangeLog-1999:	* event-loop.h: Add extern declarations for handle_stop_sig,
ChangeLog-1999:	(init_main): Move ``extern'' vars from here to event-loop.h.
ChangeLog-1999:	* event-loop.c (gdb_wait_for_event): Initialize num_found to 0.
ChangeLog-1999:	* event-top.c (async_hook): Delete extern declaration.
ChangeLog-1999:	(main): Hook in the asynchronous event-loop based CLI using
ChangeLog-1999:	(struct inf): Use `unsigned int' instead of `int' for bit-fields.
ChangeLog-1999:	Add new bit-field named `nomsg'.
ChangeLog-1999:	* main.c: Include "event-loop.h".
ChangeLog-1999: 	set_async_prompt), event-loop.c (display_gdb_prompt): Move
ChangeLog-1999:	* event-loop.h: To here.
ChangeLog-1999:	* event-loop.h (delete_async_signal_handler): Add function
ChangeLog-1999:	* event-top.c (change_annotation_level, command_handler): Add
ChangeLog-1999:	* event-top.c: Ditto.
ChangeLog-1999:	* event-loop.c: Ditto.
ChangeLog-1999:	* event-loop.h: Include sys/wait.h only if HAVE_SYS_WAIT_H.
ChangeLog-1999:	* event-top.c (change_line_handler): Use POLLIN instead of
ChangeLog-1999:	* top.c: Include event-loop.h.
ChangeLog-1999:	event-top.c can use them.
ChangeLog-1999:	(command_loop_marker): Make non-static, for use in event-top.c.
ChangeLog-1999:	Include event-loop.h.
ChangeLog-1999:	event-loop.c.  Add new global variable async to determine whether 
ChangeLog-1999:	* event-top.c: New file. Gdb input line handler and command line
ChangeLog-1999:	* event-loop.h: New file. Data structures and definitions for the
ChangeLog-1999:	* event-loop.c: New file. Functions for the event loop 
ChangeLog-1999:	(event-loop.o): Add rule for target object.
ChangeLog-1999:	(event-top.o): Ditto.
ChangeLog-1999:	the result will be passed to value_at which expects host-byte
ChangeLog-1999: 	sparcl-stub, sparclet-stub.c: Change declaration of putDebugChar
ChangeLog-1999:	remote-udi.c rom68k-rom.c sh3-rom.c sparcl-tdep.c sparclet-rom.c 
ChangeLog-1999:left-margin: 8
ChangeLog-2000:	environ.c, event-loop.c, event-top.c, exec.c, f-lang.c,
ChangeLog-2000:        This set of changes add "hookpost-" as an expansion on the original
ChangeLog-2000:	New function.  Construct target-specific link map offsets.
ChangeLog-2000:	New function.  Construct target-specific link map offsets.
ChangeLog-2000:	Corrected comment spelling dependant->dependent.
ChangeLog-2000:	* dst.h eval.c event-loop.c: Corrected comment spelling.
ChangeLog-2000:	* event-top.c gdb-events.sh: Corrected comment spelling.
ChangeLog-2000:	dependant->dependent.
ChangeLog-2000:	dependant->dependent.
ChangeLog-2000:	environ.c, eval.c, event-top.c, exec.c, expprint.c, f-lang.c,
ChangeLog-2000:	sparc-tdep.c, sparcl-stub.c, sparcl-tdep.c, sparclet-rom.c,
ChangeLog-2000:	sparclet-stub.c, stabsread.c, stack.c, standalone.c,
ChangeLog-2000:	* event-top.c (command_handler), top.c (simplified_command_loop,
ChangeLog-2000:	* event-loop.c: Include either <poll.h> or <sys/poll.h>.
ChangeLog-2000:	sparclet-rom.c, srec.h, stabsread.c, stabsread.h, stack.c,
ChangeLog-2000:	(command_loop, simplified_command_loop), event-top.c
ChangeLog-2000:	* event-top.c (command_handler): Ditto.
ChangeLog-2000:	* sparclet-rom.c (sparclet_regnames): Initialize explicitly, to
ChangeLog-2000:	(step_over_function): Only modify step_resume_breakpoint->frame if
ChangeLog-2000:	(test-mapping, mapping_test, test_mapping_cmd) Remove (test only).
ChangeLog-2000:	* event-top.c (command_handler): Use data as a union.
ChangeLog-2000:	* event-loop.c (handle_file_event): Run through indent.
ChangeLog-2000:	* event-loop.c (sys/types.h): File now included unconditionally.
ChangeLog-2000:	(gdb_notifier): poll- and select-versions merged.
ChangeLog-2000:	(create_file_handler): Select poll- or select-version according to
ChangeLog-2000:	out that these are target-dependent, and useful in non-native
ChangeLog-2000:	* event-loop.c (top-level) [NO_FD_SET]: Deprecate this branch.
ChangeLog-2000:	* event-top.c (_initialize_event_loop): If instream is not
ChangeLog-2000:	* event-loop.c (poll_timers): Don't compare delta.tv_sec with
ChangeLog-2000:	* event-loop.h: Eliminate uses of PTR, use 'void *' instead.
ChangeLog-2000:	* event-top.c: Ditto.
ChangeLog-2000:	"info port-rights" command.
ChangeLog-2000:	* event-top.c (display_gdb_prompt): When interpreter_p, assume
ChangeLog-2000:	* event-loop.c (handle_file_event): In case of poll, enable
ChangeLog-2000:        * m32r-stub.c, sparcl-stub.c, sparclet-stub.c (handle_exception):
ChangeLog-2000:	* event-top.c (stdin_event_handler): call quit_command rather than
ChangeLog-2000:left-margin: 8
ChangeLog-2001:	m68*-*bug-*, m68*-monitor-* and m68*-est-* targets.
ChangeLog-2001:	* event-loop.c (start_event_loop): Call
ChangeLog-2001:	* event-top.h (after_char_processing_hook): Declare.
ChangeLog-2001:	* event-top.c (rl_callback_read_char_wrapper): Call
ChangeLog-2001:	(init_main): Add the operate-and-get-next defun.
ChangeLog-2001:	* s390-tdep.c: Tweak argument-passing to match GCC bugs.
ChangeLog-2001:	* event-top.c (async_stop_sig) [HAVE_SIGPROCMASK]: Some
ChangeLog-2001:	async_stop_sig from event-top.c.
ChangeLog-2001:	* configure.tgt: Add mn10300 to list of mulit-arch targets.
ChangeLog-2001:	* sparclet-rom.c: Update.
ChangeLog-2001:	* event-top.c (command_handler): Remove tui insert_mode hack.
ChangeLog-2001:	* sparclet-rom.c: Update.
ChangeLog-2001:2001-06-28  Joel Brobecker  <brobecker@act-europe.fr>
ChangeLog-2001:	* gdbarch.c: Regenerate.  Out-of-sync with gdbarch.sh.
ChangeLog-2001:2001-06-15  Joel Brobecker <brobecker@act-europe.fr>
ChangeLog-2001:	bpt->inserted will succeed, and duplicates will be fixed up.
ChangeLog-2001:	* event-top.h: Fix formatting.
ChangeLog-2001:	* event-top.c (display_gdb_prompt): Ditto.
ChangeLog-2001:	(m68*-est-*, m68*-sony-*, m68*-isi-*):
ChangeLog-2001:	* event-loop.c (#include "top.h"): Removed.
ChangeLog-2001:	* event-loop.c (toplevel) [!HAVE_POLL] [NO_FD_SET]: Remove unused
ChangeLog-2001:	* go32-nat.c <top level>: Remove prototypes for watchpoint-
ChangeLog-2001:	related functions.  Remove definitions of watchpoint-related
ChangeLog-2001:	activates debugging print-outs in functions which insert, remove,
ChangeLog-2001:	* event-loop.c (create_file_handler): Ditto.
ChangeLog-2001:	* event-loop.c (#include <setjmp.h>): Removed.
ChangeLog-2001:	elfread.c, environ.c, environ.h, eval.c, event-loop.c,
ChangeLog-2001:	event-loop.h, event-top.c, exec.c, expprint.c, f-exp.y,
ChangeLog-2001:	sparclet-rom.c, srec.h, stabsread.c, stabsread.h, stack.c,
ChangeLog-2001:	* sparclet-rom.c: Ditto.
ChangeLog-2001:	From 2001-02-11 Paul Hilfinger <hilfingr@lisbon.int.act-europe.fr>
ChangeLog-2001:	* event-loop.c: Ditto.
ChangeLog-2001:	* event-top.h [!STOP_SIGNAL]: #include <signal.h>.
ChangeLog-2001:	* event-top.c: Remove duplicate #include <signal.h>.
ChangeLog-2001:	* event-top.c (#include <signal.h>): Changed from signals.h.
ChangeLog-2001:	(sh_gdbarch_init): Initialize gdbarch_extract-return_value to new
ChangeLog-2001:	* event-loop.c: Change inclusion of string.h to gdb_string.h and
ChangeLog-2001:left-margin: 8
ChangeLog-2002:	(event-top.o): Ditto.
ChangeLog-2002:	* event-top.c (gdb_disable_readline): New function.
ChangeLog-2002:	* event-loop.c (start_event_loop): Add comment.
ChangeLog-2002:	* event-top.c (gdb_setup_readline): New function. Code moved from
ChangeLog-2002:	* event-loop.c (start_event_loop): Rename variable 'result' to
ChangeLog-2002:	(c_emit_char): Use charset-specific methods to recognize
ChangeLog-2002:	(parse_escape): Use charset-specific methods to recognize
ChangeLog-2002:	bizarre argument-passing behavior, along with the comment describing
ChangeLog-2002:	* event-loop.c (gdb_do_one_event): Make public.
ChangeLog-2002:	* event-loop.h (gdb_do_one_event): Declare.
ChangeLog-2002:	* gdb-events.sh: Add target-changed event.
ChangeLog-2002:	* valops.c (value_assign): Add target-changed event notification
ChangeLog-2002:	operate-and-get-next functions correctly even when the history
ChangeLog-2002:	* event-top.c (command_line_handler): Don't read past
ChangeLog-2002:	trust-readonly-sections `show' documentation.
ChangeLog-2002:	* event-top.c (command_handler): Don't use space_at_cmd_start
ChangeLog-2002:	trust-readonly-sections'.
ChangeLog-2002:	(_initialize_i386_tdep): Add new 'struct-convcention' command.
ChangeLog-2002:	* event-loop.c (create_file_handler): Don't do anything but
ChangeLog-2002:	"trust-readonly-sections".
ChangeLog-2002:	sorted in most most-recent-used order.  Document.
ChangeLog-2002:	* event-top.c (command_line_handler): Remove useless if.
ChangeLog-2002:	``E'' step out-of-range packets.
ChangeLog-2002:	* valarith.c (value_x_unop): Fix decrement; support post-decrement.
ChangeLog-2002:	with other related struct-returning functions.
ChangeLog-2002:	* sparclet-rom.c (sparclet_load): Ditto.
ChangeLog-2002:	* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
ChangeLog-2002:	(do_xfer_memory): Add missing line to trust-readonly
ChangeLog-2002:	* NEWS: Mention "set trust-readonly-sections" command.
ChangeLog-2002:	* target.c: New command, "set trust-readonly-sections on".
ChangeLog-2002:	(initialize_targets): Register command "set trust-readonly-sections".
ChangeLog-2002:	* defs.h, event-top.c, gdbcmd.h: Ditto.
ChangeLog-2002:	* event-top.c (display_gdb_prompt): Ditto.
ChangeLog-2002:left-margin: 8
ChangeLog-2003:	m68*-bull*-sysv*, m68*-att-*, m680[01]0-sun-sunos4*, and
ChangeLog-2003:	m68*-bull-sysv*, m68*-att-*, and m68*-motorola-*, as obsolete.
ChangeLog-2003:	"set remote-mips64-transfers-32bit-regs" command.  Specify
ChangeLog-2003:	* event-top.c (command_line_handler): Ditto.
ChangeLog-2003:	gdb/sparclet-rom.c, gdb/sparclet-stub.c,
ChangeLog-2003:	mips*-*-mach3*, i[3456]86-sequent-sysv4*, i[3456]86-sequent-sysv*,
ChangeLog-2003:	i[3456]86-sequent-bsd*, sparclet-*-*, sparclite-fujitsu-none, and
ChangeLog-2003:	* sparclet-stub.c, sparclet-rom.c: Delete obsolete file.
ChangeLog-2003:	(i386_gdbarch_init): Initialze register set-related members of
ChangeLog-2003:2003-09-29  Jerome Guitton  <guitton@act-europe.fr>
ChangeLog-2003:2003-09-25  Jerome Guitton  <guitton@act-europe.fr>
ChangeLog-2003:2003-09-25  Jerome Guitton  <guitton@act-europe.fr>
ChangeLog-2003:	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
ChangeLog-2003:	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
ChangeLog-2003:	* config/mips/embed64.mt: Delete out-of-date comment.
ChangeLog-2003:	compiles with -Wformat-nonliteral -Werror.
ChangeLog-2003:	* NEWS: Mention that "set prompt-escape-char" was deleted.
ChangeLog-2003:	prompt-escape-char" command.
ChangeLog-2003:	-Werror.  -Wformat-nonliteral problems.
ChangeLog-2003:	backtrace-below-main" with "set/show backtrace past-main".  Add
ChangeLog-2003:	* event-top.c (command_line_handler): Ditto.
ChangeLog-2003:	* configure.in (build_warnings): Add -Wformat-nonliteral.
ChangeLog-2003:	replace out-of-date comment.
ChangeLog-2003:	* event-top.c (command_handler): Likewise.
ChangeLog-2003:	* ser-pipe.c (_initialize_ser_pipe): Correct call to memset--swap
ChangeLog-2003:	Use set/show mechanism for charset, host-charset, target-charset
ChangeLog-2003:	commands. Do not make 'show host-charset' and 'show
ChangeLog-2003:	target-charset' be aliases of 'show charset'.
ChangeLog-2003:	(_initialize_valops): Move "set/show coerce-float-to-double", and
ChangeLog-2003:	* NEWS: Mention that sparclet-*-* and sparclite-*-* have been made
ChangeLog-2003:	* sparclet-stub.c: Obsolete file.
ChangeLog-2003:	* sparclet-rom.c: Obsolete file.
ChangeLog-2003:	* configure.tgt: Make sparclet-*-*, sparclite-*-*, and
ChangeLog-2003:	* i387-tdep.h, gdbthread.h, event-top.h, gdb.h: Ditto.
ChangeLog-2003:	* configure.tgt: Obsolete i[3456]86-sequent-bsd*,
ChangeLog-2003:	i[3456]86-sequent-sysv4*, and i[3456]86-sequent-sysv*.
ChangeLog-2003:	* configure.host: Obsolete i[3456]86-sequent-bsd*,
ChangeLog-2003:	i[3456]86-sequent-sysv4*, and i[3456]86-sequent-sysv*.
ChangeLog-2003:	(_initialize_f_language): Gdbarch-register built-in fortran types.
ChangeLog-2003:	hardware-watchpoint-limit" and "set/show remote
ChangeLog-2003:	hardware-breakpoint-limit".
ChangeLog-2003:	just-loaded dll.
ChangeLog-2003:	* event-top.c (cli_command_loop): Delete declaration.
ChangeLog-2003:	* event-top.h (cli_command_loop): Declare.  Update copyright.
ChangeLog-2003:	(mi-main.o, main.o, event-top.o): Update dependencies.
ChangeLog-2003:	* event-top.h (gdb_setup_readline): Declare.
ChangeLog-2003:	* event-top.c: Include "interps.h".
ChangeLog-2003:	(_initialize_valops): Add "set coerce-float-to-double".
ChangeLog-2003:	--without-included regex option, and move it into the "Checks for
ChangeLog-2003:left-margin: 8
ChangeLog-2004:	(inf_ttrace_target): Initialize "hardware" watchpoint-related
ChangeLog-2004:	information to help us determine whether it's a struct-return
ChangeLog-2004:	* config/pa/hppahpux.mh (NATDEPFILES): Move target-specific support 
ChangeLog-2004:	* config/pa/hppa64.mt (TDEPFILES): Put target-specific support 
ChangeLog-2004:	* values.c (modify_field): Correct handling of bit-fields that
ChangeLog-2004:	* event-top.c (gdb_readline2): Likewise.
ChangeLog-2004:	* ada-lex.l: Remove useless rule whose right-context clause
ChangeLog-2004:2004-10-08 Eric Botcazou  <ebotcazou@act-europe.fr>	
ChangeLog-2004:	left-justify the value if it comes with a modular type.
ChangeLog-2004:	* event-top.c (gdb_setup_readline, gdb_disable_readline): Simplify.
ChangeLog-2004:	* defs.h: Remove out-of-date comment.
ChangeLog-2004:	processing happens before other step-out-of-range handling.
ChangeLog-2004:	* dbxread.c (read_dbx_symtab): Set pst->dirname when known.
ChangeLog-2004:	(dwarf2_build_psymtabs_hard): Set pst->dirname when known.
ChangeLog-2004:	* mi/mi-cmds.c (mi_cmd_mi_cmds): Add -file-list-exec-source-files.
ChangeLog-2004:	(possible_user_operator_p): Idiot-proof against null values.
ChangeLog-2004:	Add post-parser entry.
ChangeLog-2004:	Add some bullet-proofing.
ChangeLog-2004:	(fbsd_make_corefile_notes): Use regset-based core file support
ChangeLog-2004:	* regset.h: Make prototype const-correct.
ChangeLog-2004:	* regset.c (regset_xmalloc): Make const-correct.
ChangeLog-2004:	parse_exp_1.  Calls language-dependent post-parser after
ChangeLog-2004:	* p-lang.c (pascal_language_defn): Add trivial post-parser.
ChangeLog-2004:	m68*-bull-sysv*, m68*-att-*, m68*-motorola-*, m68*-*-lynxos*,
ChangeLog-2004:	m680[01]0-sun-sunos4*, m68*-att-*, m68*-bull*-sysv*,
ChangeLog-2004:	* dummy-frame.h: Delete out-of-date comments.
ChangeLog-2004:	declaration and out-of-date comment.
ChangeLog-2004:	* infrun.c (handle_inferior_event): Remove short-circuit code for
ChangeLog-2004:	* source.c, solib.c, exec.c, event-top.c: Ditto.
ChangeLog-2004:	struct-return and inferior function call methods.
ChangeLog-2004:	* event-top.c (async_request_quit): Remove uses of REQUEST_QUIT
ChangeLog-2004:	use s390_inferior_tid.  Add short-cut for the no watchpoint case.
ChangeLog-2004:	sim/sh64/sem-compact-switch.c, sim/sh64/sem-media-switch.c,
ChangeLog-2004:left-margin: 8
ChangeLog-2005:	* event-top.h: 
ChangeLog-2005:	* event-top.c: 
ChangeLog-2005:	* event-loop.h: 
ChangeLog-2005:	* event-loop.c: 
ChangeLog-2005:	* mt-tdep.c: 
ChangeLog-2005:	* mt-tdep.c (mt_arch_constants, mt_gdb_regnums): Rename, adjust.
ChangeLog-2005:	(_initialize_values): Add command init-if-undefined.
ChangeLog-2005:	Mention new command init-if-undefined.
ChangeLog-2005:	* event-top.h (async_init_signals): Add SIGTERM handler.
ChangeLog-2005:	* event-top.h (handle_sigterm): New prototype.
ChangeLog-2005:	(gdbmi-var-list-children-handler, gdbmi-var-list-children-regexp):
ChangeLog-2005:	(gdb-stack-list-locals-handler): Handle string expressions properly.
ChangeLog-2005:	(gdb-data-list-register-values-handler)
ChangeLog-2005:	(gdb-data-list-register-values-custom): Fontify buffer.
ChangeLog-2005:	not short-circuit resuming all threads if the signal will be ignored
ChangeLog-2005:	* event-top.c (gdb_setup_readline): Add missing type in extern
ChangeLog-2005:	* event-top.c (gdb_setup_readline): Don't set gdb_stdout when
ChangeLog-2005:	(handle_unload_dll): Remove left-over cruft.
ChangeLog-2005:	(test-cp-names.o): Renamed to test-cp-name-parser.o.
ChangeLog-2005:	(test-cp-names): Renamed to test-cp-name-parser.
ChangeLog-2005:	* event-loop.c (gdb_select): Program defensively.
ChangeLog-2005:	* event-loop.c (gdb_assert.h): Include.
ChangeLog-2005:	* Makefile.in (event-loop.o): Depend on $(gdb_assert_h).
ChangeLog-2005:	"set remote get-thread-local-storage-address-packet" and
ChangeLog-2005:	"show remote get-thread-local-address-packet".
ChangeLog-2005:	* ser-unix.c (event-loop.h): Do not include it.
ChangeLog-2005:	* event-top.c (handle_sigquit): Do not define for systems without
ChangeLog-2005:	(test-cp-names.o, test-cp-names$(EXEEXT), cp-names.o): New rules.
ChangeLog-2005:	(clean): Remove test-cp-names$(EXEEXT).
ChangeLog-2005:	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
ChangeLog-2005:	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
ChangeLog-2005:	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
ChangeLog-2005:	* event-top.c (command_line_handler): Do not set error_pre_print.
ChangeLog-2005:	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
ChangeLog-2005:left-margin: 8
ChangeLog-3.x:	default-dep.c (exec_file_command): Check for errors from stat,
ChangeLog-3.x:	* hp300bsd-dep.c: Stay in sync with default-dep.c.
ChangeLog-3.x:	Have "*" <int-valued-exp> return an int, not a LONGEST.
ChangeLog-3.x:	* config.gdb: Accept sequent-i386 (not seq386).
ChangeLog-3.x:	* default-dep.c (read_inferior_memory): Put #if 0'd out comment
ChangeLog-3.x:	* default-dep.c (read_inferior_memory): Move #endif after else.
ChangeLog-3.x:	pst->filename to pst->dependencies[i]->filename.
ChangeLog-3.x:	* default-dep.c (core_file_command): Made reg_offset unsigned.
ChangeLog-3.x:	* default-dep.c (core_file_command): Improved error messages for
ChangeLog-3.x:	* default-dep.c (core_file_command): Fixed typo.
ChangeLog-3.x:	* default-dep.c: Deleted inclusion of fcntl.h; apparently not
ChangeLog-3.x:	to eliminate some shift-reduce conflicts.
ChangeLog-3.x:	* default-dep.c: Moved include of sys/user.h to after include of
ChangeLog-3.x:	* infrun.c (normal_stop): Changed references to "unset-env" to
ChangeLog-3.x:	* infcmd.c (_initialize_infcmd): Change reference to set-args in
ChangeLog-3.x:	* default-dep.c: Include a.out.encap.h if COFF_ENCAPSULATE.
ChangeLog-3.x:	* symtab.h, dbxread.c (psymtab_to_symtab): Recognize pst->ldsymlen
ChangeLog-3.x:	m-npl.h, m-pn.h, m-sparc.h, m-sun3.h, m-vax.h, default-dep.c,
ChangeLog-3.x:	* convex-dep.c, default-dep.c, gould-dep.c, hp9k320-dep.c,
ChangeLog-3.x:	for delete, and changed "unset-environment" to be the
ChangeLog-3.x:	breaking the set-* commands into subcommands of set.  Changed "set
ChangeLog-3.x:	* infcmd.c,printcmd,c,main.c,valprint.c: Changed the set-*
ChangeLog-3.x:	* default-infdep.c: #ifdef SYSTEMV, include header file types.h.
ChangeLog-3.x:left-margin: 8
charset.c:     (mostly target->host conversions),
charset.c:   - building target-appropriate representations of strings and
charset.c:     characters the user enters in expressions (mostly host->target
charset.c:  /* Pointers to charset-specific functions that depend only on a
charset.c:  t->next = all_translations;
charset.c:  for (t = all_translations; t; t = t->next)
charset.c:    if (! strcmp (from, t->from)
charset.c:        && ! strcmp (to, t->to))
charset.c:  t->from = from;
charset.c:  t->to = to;
charset.c:  t->c_target_char_has_backslash_escape = c_target_char_has_backslash_escape;
charset.c:  t->c_target_char_has_backslash_escape_baton
charset.c:  t->c_parse_backslash = c_parse_backslash;
charset.c:  t->c_parse_backslash_baton = c_parse_backslash_baton;
charset.c:  t->convert_char = table_convert_char;
charset.c:  t->convert_char_baton = (void *) table;
charset.c:  h2t = lookup_translation (host->name, target->name);
charset.c:  t2h = lookup_translation (target->name, host->name);
charset.c:      if (! h2t || ! h2t->convert_char)
charset.c:                   host->name, target->name);
charset.c:                   target->name, host->name);
charset.c:  if (h2t && h2t->c_parse_backslash)
charset.c:      c_parse_backslash_func = h2t->c_parse_backslash;
charset.c:      c_parse_backslash_baton = h2t->c_parse_backslash_baton;
charset.c:  if (h2t && h2t->convert_char)
charset.c:      host_char_to_target_func = h2t->convert_char;
charset.c:      host_char_to_target_baton = h2t->convert_char_baton;
charset.c:/* 'Set charset', 'set host-charset', 'set target-charset', 'show
charset.c:/* 'set host-charset' command sfunc.  We need a wrapper here because
charset.c:/* Wrapper for the 'set target-charset' command.  */
charset.c:  return current_host_charset->name;
charset.c:  return current_target_charset->name;
charset.c:  return ((*current_host_charset->host_char_print_literally)
charset.c:          (current_host_charset->host_char_print_literally_baton,
charset.c:  return ((*current_target_charset->target_char_to_control_char)
charset.c:          (current_target_charset->target_char_to_control_char_baton,
charset.c:  add_setshow_enum_cmd ("host-charset", class_support,
charset.c:To see a list of the character sets GDB supports, type `set host-charset <TAB>'."),
charset.c:  add_setshow_enum_cmd ("target-charset", class_support,
charset.c:To see a list of the character sets GDB supports, type `set target-charset'<TAB>"),
charset.h:   characters in a character-set-independent way.  They are both
charset.h:   language-specific (to C and C++) and character-set-specific.
coffread.c:         --split-by-reloc.  */
coffread.c:  if (sect->target_index == args->targ_index)
coffread.c:	off = sect->index;
coffread.c:  count = asect->lineno_count;
coffread.c:  offset = asect->line_filepos;
coffread.c:			       info->stabstrsect->filepos, stabstrsize);
coffread.c:	       gone) "set fast-symbolic-addr off" kludge.  */
coffread.c:	         for which we do not have any other statement-line-number. */
coffread.c:	  list->field.name =
coffread.c:	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
coffread.c:	  FIELD_BITPOS (list->field) = 8 * ms->c_value;
coffread.c:	  FIELD_BITSIZE (list->field) = 0;
coffread.c:	  FIELD_STATIC_KIND (list->field) = 0;
coffread.c:	  list->field.name =
coffread.c:	  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type, &sub_aux);
coffread.c:	  FIELD_BITPOS (list->field) = ms->c_value;
coffread.c:	  FIELD_BITSIZE (list->field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;
coffread.c:	  FIELD_STATIC_KIND (list->field) = 0;
coffread.c:  for (n = nfields; list; list = list->next)
coffread.c:    TYPE_FIELD (type, --n) = list->field;
coff-solib.c:	  len = bfd_get_32 (exec_bfd, ent->len);
coff-solib.c:	  nameoffset = bfd_get_32 (exec_bfd, ent->nameoffset);
complaints.c:       complaint = complaint->next)
complaints.c:      if (complaint->fmt == fmt
complaints.c:	  && complaint->file == file
complaints.c:	  && complaint->line == line)
complaints.c:  complaint->fmt = fmt;
complaints.c:  complaint->file = file;
complaints.c:  complaint->line = line;
complaints.c:  complaint->counter = 0;
complaints.c:  complaint->next = NULL;
complaints.c:  complaint->next = complaints->root;
complaints.c:  complaint->counter++;
complaints.c:  if (complaint->counter > stop_whining)
complaints.c:  if (complaint->file != NULL)
complaints.c:    internal_vwarning (complaint->file, complaint->line, complaint->fmt, args);
complaints.c:    (*deprecated_warning_hook) (complaint->fmt, args);
complaints.c:	vwarning (complaint->fmt, args);
complaints.c:	  msg = xstrvprintf (complaint->fmt, args);
completer.c:   "show output-" "radix"
completer.c:	      list = complete_on_cmdlist (*result_list->prefixlist, p,
configure:    # Obsolete; use --without-fp.
configure:  -without-* | --without-*)
configure:    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
configure:  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
configure:  --with-libexpat-prefix[=DIR]  search for libexpat in DIR/include and DIR/lib
configure:  --without-libexpat-prefix     don't search for libexpat in includedir and libdir
configure:  --without-included-regex don't use included regex; this is the default
configure:	  | -with-* | --with-* | -without-* | --without-* | --x)
configure:/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
configure:# Check whether --with-separate-debug-dir or --without-separate-debug-dir was given.
configure:# Check whether --with-libunwind or --without-libunwind was given.
configure:# Check whether --with-gnu-ld or --without-gnu-ld was given.
configure:  # Check if gcc -print-prog-name=ld gives a path.
configure:    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
configure:    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
configure:# Check whether --with-libexpat-prefix or --without-libexpat-prefix was given.
configure:  echo "$as_me:$LINENO: result: ${acx_cv_type_int64_t-'using preprocessor symbols'}" >&5
configure:echo "${ECHO_T}${acx_cv_type_int64_t-'using preprocessor symbols'}" >&6
configure:# Check whether --with-included-regex or --without-included-regex was given.
configure:            # The GNU linker requires the -export-dynamic option to make
configure:            echo "$as_me:$LINENO: checking for the ld -export-dynamic flag" >&5
configure:echo $ECHO_N "checking for the ld -export-dynamic flag... $ECHO_C" >&6
configure:            LDFLAGS="${LDFLAGS} -Wl,-export-dynamic"
configure:               CONFIG_LDFLAGS="${CONFIG_LDFLAGS} -Wl,-export-dynamic"
configure:# Check whether --with-sysroot or --without-sysroot was given.
configure:-Wformat -Wparentheses -Wpointer-arith -Wformat-nonliteral \
configure:# -Wchar-subscripts -Wtraditional -Wshadow -Wcast-qual
configure:# -Wcast-align -Wwrite-strings -Wconversion -Wstrict-prototypes
configure:# -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls
configure:# Add any host-specific objects to GDB.
configure:# Check whether --with-tclconfig or --without-tclconfig was given.
configure:# Check whether --with-tkconfig or --without-tkconfig was given.
configure:# Check whether --with-tclinclude or --without-tclinclude was given.
configure:# Check whether --with-tkinclude or --without-tkinclude was given.
configure:# Check whether --with-itclconfig or --without-itclconfig was given.
configure:# Check whether --with-itkconfig or --without-itkconfig was given.
configure:# Check whether --with-x or --without-x was given.
configure:# Check whether --with-libiconv-prefix or --without-libiconv-prefix was given.
configure:  # Work around the forget-to-reset-the-flag bug.
configure:  # Work around the forget-to-reset-the-flag bug.
configure.ac:  [  --without-included-regex don't use included regex; this is the default
configure.ac:            # The GNU linker requires the -export-dynamic option to make
configure.ac:            AC_MSG_CHECKING(for the ld -export-dynamic flag)
configure.ac:            LDFLAGS="${LDFLAGS} -Wl,-export-dynamic"
configure.ac:               CONFIG_LDFLAGS="${CONFIG_LDFLAGS} -Wl,-export-dynamic"
configure.ac:-Wformat -Wparentheses -Wpointer-arith -Wformat-nonliteral \
configure.ac:# -Wchar-subscripts -Wtraditional -Wshadow -Wcast-qual
configure.ac:# -Wcast-align -Wwrite-strings -Wconversion -Wstrict-prototypes
configure.ac:# -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls
configure.ac:# Add any host-specific objects to GDB.
configure.host:#  gdb_host_obs			host-specific .o files to include
configure.tgt:mt-*-*)			gdb_target=mt ;;
copying.awk:	  print "  immediate_quit--;";
copying.awk:	  print "  immediate_quit--;";
copying.c:  immediate_quit--;
copying.c:  immediate_quit--;
corefile.c:    (t->to_detach) (filename, from_tty);
corefile.c:    (t->to_open) (filename, from_tty);
corelow.c:      && asect->filepos == reg_sect->filepos)	/* Did we find .reg? */
corelow.c:      regset->supply_regset (regset, current_regcache, -1, contents, size);
cp-name-parser.c:  ret->type = d_type;
cp-name-parser.c:   if the built-in stack extension method is used).
cp-name-parser.c:  ret->used = 0;
cp-name-parser.c:  if (result->type == GLOBAL_DESTRUCTORS)
cp-name-parser.c:  else if (result->type == GLOBAL_CONSTRUCTORS)
cp-name-parser.c:  if (result->type == GLOBAL_DESTRUCTORS)
cp-name-parser.c:  else if (result->type == GLOBAL_CONSTRUCTORS)
cp-name-parser.y:  ret->type = d_type;
cp-name-parser.y:/* Also an integral constant-expression of integral type, and a
cp-name-parser.y:  ret->used = 0;
cp-name-parser.y:  if (result->type == GLOBAL_DESTRUCTORS)
cp-name-parser.y:  else if (result->type == GLOBAL_CONSTRUCTORS)
cp-name-parser.y:  if (result->type == GLOBAL_DESTRUCTORS)
cp-name-parser.y:  else if (result->type == GLOBAL_CONSTRUCTORS)
cp-namespace.c:  for (current = using_list; current != NULL; current = current->next)
cp-namespace.c:      if ((strncmp (current->inner, name, inner_length) == 0)
cp-namespace.c:	  && (strlen (current->inner) == inner_length)
cp-namespace.c:	  && (strlen (current->outer) == outer_length))
cp-namespace.c:       current = current->next)
cp-namespace.c:      if (strcmp (namespace, current->outer) == 0)
cp-namespace.c:	  sym = cp_lookup_symbol_namespace (current->inner,
cp-support.c:       current = current->next)
cp-support.c:      if (strcmp (namespace, current->outer) == 0)
cp-support.c:					   current->inner);
cris-tdep.c:   If the compilation option -fno-omit-frame-pointer is present the
cris-tdep.c:   The prologue may consist of (-fno-omit-frame-pointer)
cris-tdep.c:               pattern for "clear" is partly  matched in the bit-pattern
cris-tdep.c:               (the two lower bits must be zero), while the bit-pattern
d10v-tdep.c:// OBSOLETE /* Target-dependent code for Renesas D10V, for GDB.
d10v-tdep.c:// OBSOLETE       /* All single byte values go in a register stored right-aligned.
d10v-tdep.c:// OBSOLETE      STRUCT_ADDR) will consume the first argument-passing register.
d10v-tdep.c:// OBSOLETE   /* Clear the host-side trace buffer, allocating space if needed.  */
d10v-tdep.c:// OBSOLETE   /* Move the data to the host-side trace buffer, adjusting counts to
d10v-tdep.c:// OBSOLETE       while (count-- > 0)
dbxread.c:   Since BFD doesn't know how to read debug symbols in a format-independent
dbxread.c:   linked using --split-by-reloc).  */
dbxread.c:		&& nlist.n_value >= pst->textlow)
dbxread.c:			     nlist.n_value > pst->texthigh
dbxread.c:			     ? nlist.n_value : pst->texthigh,
dbxread.c:				 valu > pst->texthigh ? valu : pst->texthigh,
dbxread.c:		pst->dirname = dirname_nso;
dbxread.c:	    if (pst && strcmp (namestring, pst->filename) == 0)
dbxread.c:	    if (pst->texthigh == 0 || valu > pst->texthigh)
dbxread.c:	      pst->texthigh = valu;
dbxread.c:		  find_stab_function_addr (namestring, pst->filename, objfile);
dbxread.c:		pst->textlow = nlist.n_value;
dbxread.c:		    || (nlist.n_value < pst->textlow
dbxread.c:		pst->textlow = nlist.n_value;
dbxread.c:		  find_stab_function_addr (namestring, pst->filename, objfile);
dbxread.c:		pst->textlow = nlist.n_value;
dbxread.c:		    || (nlist.n_value < pst->textlow
dbxread.c:		pst->textlow = nlist.n_value;
dbxread.c:	     end_psymtab will set pst->texthigh to the proper value, which
dbxread.c:      /* Don't set pst->texthigh lower than it already is.  */
dbxread.c:		   text_end > pst->texthigh ? text_end : pst->texthigh,
dbxread.c:  result->read_symtab_private = (char *)
dbxread.c:  result->read_symtab = dbx_psymtab_to_symtab;
dbxread.c:  struct objfile *objfile = pst->objfile;
dbxread.c:  pst->texthigh = capping_text;
dbxread.c:  if (pst->texthigh == 0 && last_function_name)
dbxread.c:      minsym = lookup_minimal_symbol (p, pst->filename, objfile);
dbxread.c:	  minsym = lookup_minimal_symbol (p, pst->filename, objfile);
dbxread.c:	pst->texthigh = SYMBOL_VALUE_ADDRESS (minsym) + MSYMBOL_SIZE (minsym);
dbxread.c:    pst->textlow = pst->texthigh;
dbxread.c:	    p1->texthigh = pst->textlow;
dbxread.c:  pst->n_global_syms =
dbxread.c:    objfile->global_psymbols.next - (objfile->global_psymbols.list + pst->globals_offset);
dbxread.c:  pst->n_static_syms =
dbxread.c:    objfile->static_psymbols.next - (objfile->static_psymbols.list + pst->statics_offset);
dbxread.c:  pst->number_of_dependencies = number_dependencies;
dbxread.c:      pst->dependencies = (struct partial_symtab **)
dbxread.c:      memcpy (pst->dependencies, dependency_list,
dbxread.c:    pst->dependencies = 0;
dbxread.c:      subpst->section_offsets = pst->section_offsets;
dbxread.c:      subpst->read_symtab_private =
dbxread.c:	subpst->textlow =
dbxread.c:	subpst->texthigh = 0;
dbxread.c:      subpst->dependencies = (struct partial_symtab **)
dbxread.c:      subpst->dependencies[0] = pst;
dbxread.c:      subpst->number_of_dependencies = 1;
dbxread.c:      subpst->globals_offset =
dbxread.c:	subpst->n_global_syms =
dbxread.c:	subpst->statics_offset =
dbxread.c:	subpst->n_static_syms = 0;
dbxread.c:      subpst->readin = 0;
dbxread.c:      subpst->symtab = 0;
dbxread.c:      subpst->read_symtab = pst->read_symtab;
dbxread.c:  free_named_symtabs (pst->filename);
dbxread.c:      && pst->n_global_syms == 0
dbxread.c:      && pst->n_static_syms == 0
dbxread.c:  if (pst->readin)
dbxread.c:			  pst->filename);
dbxread.c:  for (i = 0; i < pst->number_of_dependencies; i++)
dbxread.c:    if (!pst->dependencies[i]->readin)
dbxread.c:	    printf_filtered ("%s...", pst->dependencies[i]->filename);
dbxread.c:	dbx_psymtab_to_symtab_1 (pst->dependencies[i]);
dbxread.c:      bfd_seek (pst->objfile->obfd, SYMBOL_OFFSET (pst), SEEK_SET);
dbxread.c:  pst->readin = 1;
dbxread.c:  if (pst->readin)
dbxread.c:			  pst->filename);
dbxread.c:  if (LDSYMLEN (pst) || pst->number_of_dependencies)
dbxread.c:	  printf_filtered ("Reading in symbols for %s...", pst->filename);
dbxread.c:      sym_bfd = pst->objfile->obfd;
dbxread.c:      if (DBX_STAB_SECTION (pst->objfile))
dbxread.c:	    = symfile_relocate_debug_section (pst->objfile->obfd,
dbxread.c:					      DBX_STAB_SECTION (pst->objfile),
dbxread.c:      scan_file_globals (pst->objfile);
dbxread.c:  objfile = pst->objfile;
dbxread.c:  text_offset = pst->textlow;
dbxread.c:  text_size = pst->texthigh - pst->textlow;
dbxread.c:  section_offsets = pst->section_offsets;
dbxread.c:     which comes from pst->textlow is correct. */
dbxread.c:     from pst->textlow which is correct.  */
dbxread.c:  pst->symtab = end_symtab (text_offset + text_size, objfile, SECT_OFF_TEXT (objfile));
dbxread.c:   the pst->section_offsets.  All symbols that refer to memory
dbxread.c:      for (stabsect = stabsects; stabsect != NULL; stabsect = stabsect->next)
dbxread.c:	  stabsize = bfd_section_size (sym_bfd, stabsect->section);
dbxread.c:  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;
dbxread.c:  DBX_SYMTAB_OFFSET (objfile) = stabsect->filepos;	/* XXX - FIXME: POKING INSIDE BFD DATA STRUCTURES */
defs.h:/* Basic, host-specific, and target-specific definitions for GDB.
defs.h:/* Dynamic target-system-dependent parameters for GDB. */
defs.h:/* Static target-system-dependent parameters for GDB. */
dictionary.c:       next = next->hash_next)
disasm.c:     Further, it has been supperseeded by trust-read-only-sections
doublest.c:  if (fmt->byteorder == floatformat_little
doublest.c:      || fmt->byteorder == floatformat_big)
doublest.c:    return fmt->byteorder;
doublest.c:  words = fmt->totalsize / FLOATFORMAT_CHAR_BIT;
doublest.c:  if (fmt->byteorder == floatformat_vax)
doublest.c:      gdb_assert (fmt->byteorder == floatformat_littlebyte_bigword);
doublest.c:  gdb_assert (fmt->totalsize
doublest.c:  if (order != fmt->byteorder)
doublest.c:  exponent = get_field (ufrom, order, fmt->totalsize, fmt->exp_start,
doublest.c:			fmt->exp_len);
doublest.c:  mant_bits_left = fmt->man_len;
doublest.c:  mant_off = fmt->man_start;
doublest.c:  special_exponent = exponent == 0 || exponent == fmt->exp_nan;
doublest.c:    exponent -= fmt->exp_bias;
doublest.c:    exponent = 1 - fmt->exp_bias;
doublest.c:      if (fmt->intbit == floatformat_intbit_no)
doublest.c:      mant = get_field (ufrom, order, fmt->totalsize, mant_off, mant_bits);
doublest.c:  if (get_field (ufrom, order, fmt->totalsize, fmt->sign_start, 1))
doublest.c:  enum floatformat_byteorders order = fmt->byteorder;
doublest.c:  if (order != fmt->byteorder)
doublest.c:  memset (uto, 0, (fmt->totalsize + FLOATFORMAT_CHAR_BIT - 1) 
doublest.c:      put_field (uto, order, fmt->totalsize, fmt->exp_start,
doublest.c:		 fmt->exp_len, fmt->exp_nan);
doublest.c:      put_field (uto, order, fmt->totalsize, fmt->man_start,
doublest.c:      put_field (uto, order, fmt->totalsize, fmt->sign_start, 1, 1);
doublest.c:      put_field (uto, order, fmt->totalsize, fmt->exp_start,
doublest.c:		 fmt->exp_len, fmt->exp_nan);
doublest.c:      put_field (uto, order, fmt->totalsize, fmt->man_start,
doublest.c:		 fmt->man_len, 0);
doublest.c:  put_field (uto, order, fmt->totalsize, fmt->exp_start, fmt->exp_len,
doublest.c:	     exponent + fmt->exp_bias - 1);
doublest.c:  mant_bits_left = fmt->man_len;
doublest.c:  mant_off = fmt->man_start;
doublest.c:      if (mant_bits_left == fmt->man_len
doublest.c:	  && fmt->intbit == floatformat_intbit_no)
doublest.c:      put_field (uto, order, fmt->totalsize,
doublest.c:  if (order != fmt->byteorder)
doublest.c:  gdb_assert (fmt->totalsize
doublest.c:  if (order != fmt->byteorder)
doublest.c:  return get_field (uval, order, fmt->totalsize, fmt->sign_start, 1);
doublest.c:  gdb_assert (fmt->totalsize
doublest.c:  if (order != fmt->byteorder)
doublest.c:  if (! fmt->exp_nan)
doublest.c:  exponent = get_field (uval, order, fmt->totalsize, fmt->exp_start,
doublest.c:			fmt->exp_len);
doublest.c:  if (exponent != fmt->exp_nan)
doublest.c:  mant_bits_left = fmt->man_len;
doublest.c:  mant_off = fmt->man_start;
doublest.c:      mant = get_field (uval, order, fmt->totalsize, mant_off, mant_bits);
doublest.c:      if (mant_off == fmt->man_start
doublest.c:	  && fmt->intbit == floatformat_intbit_yes)
doublest.c:  gdb_assert (fmt->totalsize
doublest.c:  if (order != fmt->byteorder)
doublest.c:  if (! fmt->exp_nan)
doublest.c:  gdb_assert (sizeof res > ((fmt->man_len + 7) / 8) * 2);
doublest.c:  mant_off = fmt->man_start;
doublest.c:  mant_bits_left = fmt->man_len;
doublest.c:  mant = get_field (uval, order, fmt->totalsize, mant_off, mant_bits);
doublest.c:      mant = get_field (uval, order, fmt->totalsize, mant_off, 32);
doublest.c:   target-dependent code, the format of floating-point types is known,
doublest.c:/* Extract a floating-point number of length LEN from a target-order
doublest.c:   target-order byte-stream at ADDR.  */
doublest.c:/* Extract a floating-point number of type TYPE from a target-order
doublest.c:/* Store VAL as a floating-point number of type TYPE to a target-order
doublest.c:   target-order byte-stream at FROM to a floating-point number of type
doublest.c:   TO_TYPE, and store it to a target-order byte-stream at TO.  */
doublest.h:/* Table of convenient float-formats.  */
dsrec.c: * byte count-+     address
dve3900-rom.c:   monitor acts perversely: for registers that it displays in bit-map
dwarf2-frame.c:      base = bfd_get_section_vma (unit->bfd, unit->dwarf_frame_section);
dwarf2-frame.c:      base += (buf - unit->dwarf_frame_buffer);
dwarf2-frame.c:      base = unit->dbase;
dwarf2-frame.c:      base = unit->tbase;
dwarf2-frame.c:      offset = buf - unit->dwarf_frame_buffer;
dwarf2-frame.c:      return (base + bfd_get_16 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:      return (base + bfd_get_32 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:      return (base + bfd_get_64 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:      return (base + bfd_get_signed_16 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:      return (base + bfd_get_signed_32 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:      return (base + bfd_get_signed_64 (unit->abfd, (bfd_byte *) buf));
dwarf2-frame.c:  struct dwarf2_cie *cie = unit->cie;
dwarf2-frame.c:  cie->next = unit->cie;
dwarf2-frame.c:  unit->cie = cie;
dwarf2-frame.c:  fde->next = objfile_data (unit->objfile, dwarf2_frame_objfile_data);
dwarf2-frame.c:  set_objfile_data (unit->objfile, dwarf2_frame_objfile_data, fde);
dwarf2-frame.c:  length = read_initial_length (unit->abfd, buf, &bytes_read);
dwarf2-frame.c:  if (end > unit->dwarf_frame_buffer + unit->dwarf_frame_size)
dwarf2-frame.c:      cie_pointer = read_8_bytes (unit->abfd, buf);
dwarf2-frame.c:      cie_pointer = read_4_bytes (unit->abfd, buf);
dwarf2-frame.c:      cie_pointer = start - unit->dwarf_frame_buffer;
dwarf2-frame.c:	obstack_alloc (&unit->objfile->objfile_obstack,
dwarf2-frame.c:      cie_version = read_1_byte (unit->abfd, buf);
dwarf2-frame.c:	read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
dwarf2-frame.c:	read_signed_leb128 (unit->abfd, buf, &bytes_read);
dwarf2-frame.c:	  cie->return_address_register = read_1_byte (unit->abfd, buf);
dwarf2-frame.c:	cie->return_address_register = read_unsigned_leb128 (unit->abfd, buf,
dwarf2-frame.c:	  length = read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
dwarf2-frame.c:	  cie_pointer = buf - unit->dwarf_frame_buffer - cie_pointer;
dwarf2-frame.c:      if (cie_pointer >= unit->dwarf_frame_size)
dwarf2-frame.c:	obstack_alloc (&unit->objfile->objfile_obstack,
dwarf2-frame.c:	  decode_frame_entry (unit, unit->dwarf_frame_buffer + cie_pointer,
dwarf2-frame.c:	  length = read_unsigned_leb128 (unit->abfd, buf, &bytes_read);
dwarf2-frame.c:      start_offset = start - unit->dwarf_frame_buffer;
dwarf2-frame.c:      ret = unit->dwarf_frame_buffer + unit->dwarf_frame_size;
dwarf2-frame.c:		 unit->dwarf_frame_section->owner->filename,
dwarf2-frame.c:		 unit->dwarf_frame_section->name);
dwarf2-frame.c:		 unit->dwarf_frame_section->owner->filename,
dwarf2-frame.c:		 unit->dwarf_frame_section->name);
dwarf2-frame.c:		 unit->dwarf_frame_section->owner->filename,
dwarf2-frame.c:		 unit->dwarf_frame_section->name);
dwarf2-frame.c:	unit.dbase = got->vma;
dwarf2-frame.c:	unit.tbase = txt->vma;
dwarf2read.c:     We will probably also want a generation counter so that most-recently-used
dwarf2read.c:  subpst->section_offsets = pst->section_offsets;
dwarf2read.c:  subpst->textlow = 0;
dwarf2read.c:  subpst->texthigh = 0;
dwarf2read.c:  subpst->dependencies = (struct partial_symtab **)
dwarf2read.c:  subpst->dependencies[0] = pst;
dwarf2read.c:  subpst->number_of_dependencies = 1;
dwarf2read.c:  subpst->globals_offset = 0;
dwarf2read.c:  subpst->n_global_syms = 0;
dwarf2read.c:  subpst->statics_offset = 0;
dwarf2read.c:  subpst->n_static_syms = 0;
dwarf2read.c:  subpst->symtab = NULL;
dwarf2read.c:  subpst->read_symtab = pst->read_symtab;
dwarf2read.c:  subpst->readin = 0;
dwarf2read.c:  subpst->read_symtab_private = NULL;
dwarf2read.c:	pst->dirname = xstrdup (comp_unit_die.dirname);
dwarf2read.c:      pst->read_symtab_private = (char *) this_cu;
dwarf2read.c:      pst->read_symtab = dwarf2_psymtab_to_symtab;
dwarf2read.c:      pst->textlow = comp_unit_die.lowpc + baseaddr;
dwarf2read.c:      pst->texthigh = comp_unit_die.highpc + baseaddr;
dwarf2read.c:      pst->n_global_syms = objfile->global_psymbols.next -
dwarf2read.c:	(objfile->global_psymbols.list + pst->globals_offset);
dwarf2read.c:      pst->n_static_syms = objfile->static_psymbols.next -
dwarf2read.c:	(objfile->static_psymbols.list + pst->statics_offset);
dwarf2read.c:      free_named_symtabs (pst->filename);
dwarf2read.c:  if (parent->scope_set)
dwarf2read.c:    return parent->scope;
dwarf2read.c:  if (parent->tag == DW_TAG_namespace
dwarf2read.c:      || parent->tag == DW_TAG_structure_type
dwarf2read.c:      || parent->tag == DW_TAG_class_type
dwarf2read.c:      || parent->tag == DW_TAG_union_type)
dwarf2read.c:	parent->scope = parent->name;
dwarf2read.c:	parent->scope = typename_concat (&cu->comp_unit_obstack, grandparent_scope,
dwarf2read.c:					 parent->name, cu);
dwarf2read.c:  else if (parent->tag == DW_TAG_enumeration_type)
dwarf2read.c:    parent->scope = grandparent_scope;
dwarf2read.c:		 parent->tag, pdi->offset);
dwarf2read.c:      parent->scope = grandparent_scope;
dwarf2read.c:  parent->scope_set = 1;
dwarf2read.c:  return parent->scope;
dwarf2read.c:      if (pst->readin)
dwarf2read.c:	  warning (_("bug: psymtab for %s is already read in."), pst->filename);
dwarf2read.c:	      printf_filtered (_("Reading in symbols for %s..."), pst->filename);
dwarf2read.c:	  dwarf2_per_objfile = objfile_data (pst->objfile,
dwarf2read.c:  for (i = 0; i < pst->number_of_dependencies; i++)
dwarf2read.c:    if (!pst->dependencies[i]->readin)
dwarf2read.c:            printf_filtered ("%s...", pst->dependencies[i]->filename);
dwarf2read.c:        psymtab_to_symtab_1 (pst->dependencies[i]);
dwarf2read.c:  per_cu = (struct dwarf2_per_cu_data *) pst->read_symtab_private;
dwarf2read.c:      pst->readin = 1;
dwarf2read.c:  process_queue (pst->objfile);
dwarf2read.c:  struct objfile *objfile = pst->objfile;
dwarf2read.c:  pst->symtab = symtab;
dwarf2read.c:  pst->readin = 1;
dwarf2read.c:      /* FIXME: carlton/2003-06-27: Once GDB is more const-correct,
dwarf2read.c:            char *pst_filename = pst->filename;
dwarf2read.c:            if (!IS_ABSOLUTE_PATH (pst_filename) && pst->dirname != NULL)
dwarf2read.c:                pst_filename = concat (pst->dirname, SLASH_STRING,
dwarf2read.c:      switch (parent->tag) {
dwarf2read.c:	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
dwarf2read.c:	      return xstrdup (TYPE_TAG_NAME (parent->type));
dwarf2read.c:	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
dwarf2read.c:	      return xstrdup (TYPE_TAG_NAME (parent->type));
dwarf2read.c:  /* The body string takes one of two forms.  For object-like macro
dwarf2read.c:     The Dwarf 2 spec says that an object-like macro's name is always
dwarf2read.c:     by either a space or null character (for an object-like macro) or
dwarf2read.c:      /* It's an object-like macro.  */
dwarf2read.c:    return slot->type;
dwarfread.c:     i[34567]86-sequent-ptx4*
dwarfread.c:     i[34567]86-sequent-sysv4*
dwarfread.c:     i[34567]86-sequent-ptx4*
dwarfread.c:     i[34567]86-sequent-sysv4*
dwarfread.c:     i[34567]86-sequent-ptx4*
dwarfread.c:     i[34567]86-sequent-sysv4*
dwarfread.c:     i860-alliant-*
dwarfread.c:	  list->field.name =
dwarfread.c:	  FIELD_TYPE (list->field) = decode_die_type (&mbr);
dwarfread.c:	  FIELD_BITPOS (list->field) = 8 * locval (&mbr);
dwarfread.c:	  FIELD_STATIC_KIND (list->field) = 0;
dwarfread.c:	  FIELD_BITSIZE (list->field) = mbr.at_bit_size;
dwarfread.c:	      FIELD_BITPOS (list->field) += mbr.at_bit_offset;
dwarfread.c:		      anonymous_size = TYPE_LENGTH (list->field.type);
dwarfread.c:		  FIELD_BITPOS (list->field) +=
dwarfread.c:      for (n = nfields; list; list = list->next)
dwarfread.c:	  TYPE_FIELD (type, --n) = list->field;
dwarfread.c:	  FIELD_TYPE (list->field) = NULL;
dwarfread.c:	  FIELD_BITSIZE (list->field) = 0;
dwarfread.c:	  FIELD_STATIC_KIND (list->field) = 0;
dwarfread.c:	  FIELD_BITPOS (list->field) =
dwarfread.c:	  list->field.name = obsavestring (scan, strlen (scan),
dwarfread.c:	  DEPRECATED_SYMBOL_NAME (sym) = create_name (list->field.name,
dwarfread.c:	  SYMBOL_VALUE (sym) = FIELD_BITPOS (list->field);
dwarfread.c:	  for (n = 0; (n < nfields) && (list != NULL); list = list->next)
dwarfread.c:	      TYPE_FIELD (type, n++) = list->field;
dwarfread.c:  abfd = pst->objfile->obfd;
dwarfread.c:  current_objfile = pst->objfile;
dwarfread.c:  base_section_offsets = pst->section_offsets;
dwarfread.c:  baseaddr = ANOFFSET (pst->section_offsets, 0);
dwarfread.c:			       GET_UNSIGNED, pst->objfile);
dwarfread.c:  process_dies (dbbase, dbbase + dbsize, pst->objfile);
dwarfread.c:  pst->symtab = pst->objfile->symtabs;
dwarfread.c:      if (pst->readin)
dwarfread.c:		   pst->filename);
dwarfread.c:	  for (i = 0; i < pst->number_of_dependencies; i++)
dwarfread.c:	      if (!pst->dependencies[i]->readin)
dwarfread.c:				       pst->dependencies[i]->filename);
dwarfread.c:		  psymtab_to_symtab_1 (pst->dependencies[i]);
dwarfread.c:	  pst->readin = 1;
dwarfread.c:      if (pst->readin)
dwarfread.c:		   pst->filename);
dwarfread.c:	  if (DBLENGTH (pst) || pst->number_of_dependencies)
dwarfread.c:				   pst->filename);
dwarfread.c:	      scan_file_globals (pst->objfile);
dwarfread.c:	  pst->texthigh = di.at_high_pc;
dwarfread.c:	  pst->read_symtab_private = (char *)
dwarfread.c:	  pst->read_symtab = dwarf_psymtab_to_symtab;
dwarfread.c:	  pst->n_global_syms = objfile->global_psymbols.next -
dwarfread.c:	    (objfile->global_psymbols.list + pst->globals_offset);
dwarfread.c:	  pst->n_static_syms = objfile->static_psymbols.next -
dwarfread.c:	    (objfile->static_psymbols.list + pst->statics_offset);
dwarfread.c:	  free_named_symtabs (pst->filename);
elfread.c:	 but have some other target-specific meaning.  */
elfread.c:				str_sect->filepos,
elfread.c:  char *filename = pst->filename;
elfread.c:      pst->section_offsets = (struct section_offsets *)
elfread.c:	(pst->section_offsets)->offsets[i] = maybe->sections[i];
event-loop.c:#include "event-loop.h"
event-loop.c:#include "event-top.h"
event-loop.c:	event_queue.last_event->next_event = event_ptr;
event-loop.h:/* Exported functions from event-loop.c */
event-top.c:#include "event-loop.h"
event-top.c:#include "event-top.h"
event-top.c:   loop as default engine, and event-top.c is merged into top.c. */
event-top.c:   for. See event-loop.h. */
event-top.c:  long space_at_cmd_start = arg->next->data.longint;
event-top.c:      printf_unfiltered (("\n\032\032post-"));
event-top.c:   See event-signal.c. */
event-top.c:   See event-signal.c. */
event-top.c:   See event-signal.c. */
event-top.c:   See event-signal.c. */
event-top.c:   See event-signal.c. */
event-top.h:/* Definitions used by event-top.c, for GDB, the GNU debugger.
event-top.h:/* Exported functions from event-top.c. 
event-top.h:/* Exported variables from event-top.c.
exec.c:      vp->toffs = sect->filepos;
exec.c:  for (p = target->to_sections; p < target->to_sections_end; p++)
exec.c:  for (p = t->to_sections; p < t->to_sections_end; p++)
exec.c:      flags = bfd_get_section_flags (exec_bfd, sect->the_bfd_section);
exec.c:	  sect->addr += text_off;
exec.c:	  sect->endaddr += text_off;
exec.c:	  sect->addr += data_off;
exec.c:	  sect->endaddr += data_off;
exec.c:	  sect->addr += bss_off;
exec.c:	  sect->endaddr += bss_off;
expprint.c:  /* Set to 1 for a right-associative operator.  */
expprint.c:         If operator is right-associative,
expprint.c:         If operator is left-associative,
expression.h:    /* NOTE: Eventually, we expect to convert to an object-oriented 
fbsd-nat.c:  gdb_assert (regset && regset->collect_regset);
fbsd-nat.c:  regset->collect_regset (regset, regcache, -1, &gregs, size);
fbsd-nat.c:  gdb_assert (regset && regset->collect_regset);
fbsd-nat.c:  regset->collect_regset (regset, regcache, -1, &fpregs, size);
f-exp.c:   if the built-in stack extension method is used).
findvar.c:   All extract a target-format integer at ADDR which is LEN bytes long.  */
f-lang.c:/* The built-in types of F77.  FIXME: integer*4 is missing, plain
f-lang.c:  0,				/* arrays are first-class (not c-style) */
f-lang.c:      tail_common_list->next = tmp;
f-lang.c:    if (current_head_bf_list->symnum_fcn == the_function)
f-lang.c:	current_head_bf_list = current_head_bf_list->next;
fork-child.c:     fact that it may expand when quoted; it is a worst-case number
fork-child.c:        to execute, and this command is "exec <target-program>
fork-child.c:        events which will confuse debugger start-up code.  */
fork-child.c:     initialize anything target-vector-specific that needs
fork-child.c:     might be used to have target-specific code initialize a variable
frame.c:  if (fi->next != NULL && fi->next->prev_pc.p)
frame.c:    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_pc.value));
frame.c:  if (fi->next != NULL && fi->next->prev_func.p)
frame.c:    fprintf_unfiltered (file, "0x%s", paddr_nz (fi->next->prev_func.addr));
frame.c:  if (this_frame->next->level >= 0
frame.c:      && this_frame->next->unwind->type != SIGTRAMP_FRAME
frame.c:   no such frame or the frame fails any of a set of target-independent
frame.c:   This function should not contain target-dependent tests, such as
frame.c:      frame->next->prev_pc.value = pc;
frame.c:      frame->next->prev_pc.p = 1;
frame.c:  add_setshow_boolean_cmd ("past-main", class_obscure,
frame.c:  add_setshow_boolean_cmd ("past-entry", class_obscure,
frame.h:   equivalent to THIS->next->unwind->what)
frame.h:   frame->next->unwind.  They all [potentially] throw an error if the
frame-unwind.c:  table->list->unwinder = dummy_frame_unwind;
frame-unwind.c:  table->osabi_head = &table->list->next;
frv-linux-tdep.c:/* Target-dependent code for GNU/Linux running on the Fujitsu FR-V,
frv-linux-tdep.c:     The frame ID's code address should be the start-address of the
frv-tdep.c:/* Target-dependent code for the Fujitsu FR-V, for GDB, the GNU Debugger.
frv-tdep.c:  while (count-- > 0 && addr >= func_start)
frv-tdep.c:          /* Spilling int-sized arguments to the stack.  */
gdbarch.c:    return  format->name;
gdbarch.c:  const char *gdb_xm_file = "<not-defined>";
gdbarch.c:  const char *gdb_nm_file = "<not-defined>";
gdbarch.c:  const char *gdb_tm_file = "<not-defined>";
gdbarch.h:/* The ABI default bit-size and format for "float", "double", and "long
gdbarch.h:   struct-convention return-value address method (the sparc saves the
gdbarch.h:   between the set-architecture command and the various GDB
gdbarch.h:/* Set the dynamic target-system-dependent parameters (architecture,
gdbarch.sh:# The ABI default bit-size and format for "float", "double", and "long
gdbarch.sh:# struct-convention return-value address method (the sparc saves the
gdbarch.sh:   between the set-architecture command and the various GDB
gdbarch.sh:/* Set the dynamic target-system-dependent parameters (architecture,
gdbarch.sh:    return  format->name;
gdbarch.sh:  const char *gdb_xm_file = "<not-defined>";
gdbarch.sh:  const char *gdb_nm_file = "<not-defined>";
gdbarch.sh:  const char *gdb_tm_file = "<not-defined>";
gdb-events.c:  event->type = breakpoint_create;
gdb-events.c:  event->data.breakpoint_create.b = b;
gdb-events.c:  event->type = breakpoint_delete;
gdb-events.c:  event->data.breakpoint_delete.b = b;
gdb-events.c:  event->type = breakpoint_modify;
gdb-events.c:  event->data.breakpoint_modify.b = b;
gdb-events.c:  event->type = tracepoint_create;
gdb-events.c:  event->data.tracepoint_create.number = number;
gdb-events.c:  event->type = tracepoint_delete;
gdb-events.c:  event->data.tracepoint_delete.number = number;
gdb-events.c:  event->type = tracepoint_modify;
gdb-events.c:  event->data.tracepoint_modify.number = number;
gdb-events.c:  event->type = architecture_changed;
gdb-events.c:      delivering_events = event->next;
gdb-events.c:      switch (event->type)
gdb-events.c:	    (event->data.breakpoint_create.b);
gdb-events.c:	    (event->data.breakpoint_delete.b);
gdb-events.c:	    (event->data.breakpoint_modify.b);
gdb-events.c:	    (event->data.tracepoint_create.number);
gdb-events.c:	    (event->data.tracepoint_delete.number);
gdb-events.c:	    (event->data.tracepoint_modify.number);
gdb-events.c:      delivering_events = event->next;
gdb-events.sh:      echo "  event->type = ${function};"
gdb-events.sh:        echo "  event->data.${function}.${arg} = ${arg};"
gdb-events.sh:      delivering_events = event->next;
gdb-events.sh:      switch (event->type)
gdb-events.sh:          ass="${ass}${sep}event->data.${function}.${arg}"
gdb-events.sh:      delivering_events = event->next;
gdb.gdb:define list-objfiles
gdb.gdb:document list-objfiles
gdb.gdb:define print-values
gdb.gdb:document print-values
gdb_mbuild.sh:# Usage: fail <message> <test-that-should-succeed>.  Should the build
gdb_thread_db.h:  TD_NOLWP,	  /* No matching light-weighted process found.  */
gdbtypes.c:   Note: the list goes backward, right-to-left. virtual_base_list()
gdbtypes.c:   occurrence in a depth-first, left-to-right search through the
gdbtypes.c:       in target form: a big-endian address left-shifted two bits.
gdbtypes.c:       in target form: a big-endian address left-shifted two bits.
gdbtypes.h:#define FT_CHAR			2	/* we use this for not-unsigned C/C++ chars */
gdbtypes.h:#define TYPE_FN_FIELD_VOFFSET(thisfn, n) ((thisfn)[n].voffset-2)
gdbtypes.h:/* Maximum and minimum values of built-in types */
glibc-tdep.c:/* Target-dependent code for the GNU C Library (glibc).
glibc-tdep.h:/* Target-dependent code for the GNU C Library (glibc).
gnu-nat.c:	for (i = search_start, left = num_threads; left; i++, left--)
gnu-nat.c:	      last->next = thread;
gnu-nat.c:	      last->next = thread;
gnu-nat.c:/* Mark our target-struct as eligible for stray "run" and "attach"
gnu-nat.c:	region_element->protection = protection;
gnu-nat.c:	region_element->start = region_address;
gnu-nat.c:	region_element->length = region_length;
gnu-nat.c:	region_element->next = region_head;
gnu-nat.c:  add_cmd ("port-rights", class_info, info_port_rights_cmd,
gnu-nat.c:  add_cmd ("port-sets", class_info, info_port_sets_cmd,
gnu-nat.c:  add_info_alias ("ports", "port-rights", 1);
gnu-nat.c:  add_info_alias ("port", "port-rights", 1);
gnu-nat.c:  add_info_alias ("psets", "port-sets", 1);
gnu-nat.h:       STATE after aborting the thread, to detect that gdb may have out-of-date
go32-nat.c:      printf_filtered (" %sAcc.", (entry & 0x20) ? "" : "Not-");
go32-nat.c:      printf_filtered (" %sCached", (entry & 0x10) ? "" : "Not-");
h8300-tdep.c:/* Target-machine dependent code for Renesas H8/300, for GDB.
hppabsd-nat.c:  t->to_fetch_registers = hppabsd_fetch_registers;
hppabsd-nat.c:  t->to_store_registers = hppabsd_store_registers;
hppabsd-tdep.c:/* Target-dependent code for HP PA-RISC BSD's.
hppa-hpux-nat.c:  t->to_fetch_registers = hppa_hpux_fetch_inferior_registers;
hppa-hpux-nat.c:  t->to_store_registers = hppa_hpux_store_inferior_registers;
hppa-hpux-nat.c:  t->to_can_run = hppa_hpux_child_can_run;
hppa-hpux-tdep.c:/* Target-dependent code for HP-UX on PA-RISC.
hppa-linux-nat.c:  t->to_fetch_registers = hppa_linux_fetch_inferior_registers;
hppa-linux-nat.c:  t->to_store_registers = hppa_linux_store_inferior_registers;
hppa-linux-tdep.c:/* Target-dependent code for GNU/Linux running on PA-RISC, for GDB.
hppa-linux-tdep.c:/* hppa-linux always uses "new-style" rt-signals.  The signal handler's return
hppa-linux-tdep.c:      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
hppa-linux-tdep.c:	  if (strcmp (osect->the_bfd_section->name, ".dynamic") == 0)
hppa-linux-tdep.c:      if (osect < faddr_sect->objfile->sections_end)
hppa-linux-tdep.c:	  addr = osect->addr;
hppa-linux-tdep.c:	  while (addr < osect->endaddr)
hppa-tdep.c:/* Target-dependent code for the HP PA-RISC architecture.
hppa-tdep.c:	      /* Small struct value are stored right-aligned.  */
hppa-tdep.c:             least-significant bits of the 64-bit storage unit, and
hppa-tdep.c:		     least-significant 32 bits of a 64-bit storage
hppa-tdep.c:	     exponent, and most-significant bits of the mantissa are
hppa-tdep.c:	     returned in GR 28; the least-significant bits of the
hppa-tdep.h:/* Target-dependent code for the HP PA-RISC architecture.
hppa-tdep.h:/* Target-dependent structure in gdbarch.  */
hpread.c:     doing this is unknown, but we bet would involve a target-
hpread.c:     LNTT from the objfile at psymtab-time, and start-up will be
hpread.c:   Since BFD doesn't know how to read debug symbols in a format-independent
hpread.c:		if (pst && !strcmp (namestring, pst->filename))
hpread.c:			pst->filename = (char *)
hpread.c:			  obstack_alloc (&pst->objfile->objfile_obstack,
hpread.c:			strcpy (pst->filename, namestring);
hpread.c:  result->textlow += offset;
hpread.c:  result->read_symtab_private = (char *)
hpread.c:  result->read_symtab = hpread_psymtab_to_symtab;
hpread.c:  struct objfile *objfile = pst->objfile;
hpread.c:  int offset = ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (objfile));
hpread.c:  pst->texthigh = capping_text + offset;
hpread.c:  pst->n_global_syms =
hpread.c:    objfile->global_psymbols.next - (objfile->global_psymbols.list + pst->globals_offset);
hpread.c:  pst->n_static_syms =
hpread.c:    objfile->static_psymbols.next - (objfile->static_psymbols.list + pst->statics_offset);
hpread.c:	      pst->filename,
hpread.c:	      pst->n_global_syms, pst->n_static_syms);
hpread.c:  pst->number_of_dependencies = number_dependencies;
hpread.c:      pst->dependencies = (struct partial_symtab **)
hpread.c:      memcpy (pst->dependencies, dependency_list,
hpread.c:    pst->dependencies = 0;
hpread.c:      subpst->section_offsets = pst->section_offsets;
hpread.c:      subpst->read_symtab_private =
hpread.c:	subpst->textlow =
hpread.c:	subpst->texthigh = 0;
hpread.c:      subpst->dependencies = (struct partial_symtab **)
hpread.c:      subpst->dependencies[0] = pst;
hpread.c:      subpst->number_of_dependencies = 1;
hpread.c:      subpst->globals_offset =
hpread.c:	subpst->n_global_syms =
hpread.c:	subpst->statics_offset =
hpread.c:	subpst->n_static_syms = 0;
hpread.c:      subpst->readin = 0;
hpread.c:      subpst->symtab = 0;
hpread.c:      subpst->read_symtab = pst->read_symtab;
hpread.c:  free_named_symtabs (pst->filename);
hpread.c:      && pst->n_global_syms == 0
hpread.c:      && pst->n_static_syms == 0)
hpread.c:  if (pst->readin)
hpread.c:			  pst->filename);
hpread.c:  for (i = 0; i < pst->number_of_dependencies; i++)
hpread.c:    if (!pst->dependencies[i]->readin)
hpread.c:	    printf_filtered ("%s...", pst->dependencies[i]->filename);
hpread.c:	hpread_psymtab_to_symtab_1 (pst->dependencies[i]);
hpread.c:      pst->symtab =
hpread.c:	hpread_expand_symtab (pst->objfile, LDSYMOFF (pst), LDSYMLEN (pst),
hpread.c:			      pst->textlow, pst->texthigh - pst->textlow,
hpread.c:			      pst->section_offsets, pst->filename);
hpread.c:  pst->readin = 1;
hpread.c:  if (pst->readin)
hpread.c:			  pst->filename);
hpread.c:  if (LDSYMLEN (pst) || pst->number_of_dependencies)
hpread.c:	  printf_filtered ("Reading in symbols for %s...", pst->filename);
hpread.c:      scan_file_globals (pst->objfile);
hpread.c:	   * initially allocate a correct-size type-vector, this code
hpread.c:/* A file-level variable which keeps track of the current-template
hpread.c:      /* First read the parent-list (classes from which we derive fields) */
hpread.c:	  FIELD_BITSIZE (list->field) = 0;
hpread.c:	  FIELD_STATIC_KIND (list->field) = 0;
hpread.c:	  FIELD_TYPE (list->field) = baseclass;
hpread.c:	  list->field.name = type_name_no_tag (FIELD_TYPE (list->field));
hpread.c:	  list->attributes = 0;
hpread.c:	      B_SET (&(list->attributes), ATTR_VIRTUAL);
hpread.c:	    FIELD_BITPOS (list->field) = parentp->dinheritance.offset;
hpread.c:	      B_SET (&(list->attributes), ATTR_PROTECT);
hpread.c:	      B_SET (&(list->attributes), ATTR_PRIVATE);
hpread.c:	  t_list->arg.name = VT (objfile) + fieldp->dtempl_arg.name;
hpread.c:	  t_list->arg.type = hpread_read_templ_arg_type (field, fieldp,
hpread.c:						 objfile, t_list->arg.name);
hpread.c:  for (n = n_templ_args; t_list; t_list = t_list->next)
hpread.c:      TYPE_TEMPLATE_ARG (type, n) = t_list->arg;
hpread.c:		  fn_list->field.name = method_name;
hpread.c:		  fn_list->field.fn_fields = (struct fn_field *) xmalloc (5 * (sizeof (struct fn_field)));
hpread.c:		  fn_list->field.length = 1;	/* Init # of overloaded instances */
hpread.c:		  fn_list->num_fn_fields = 5;	/* # of entries for which space allocated */
hpread.c:	      list->field.name = VT (objfile) + fn_fieldp->dsvar.name;
hpread.c:	      SET_FIELD_PHYSNAME (list->field, 0);	/* initialize to empty */
hpread.c:	      FIELD_TYPE (list->field) = memtype;
hpread.c:	      list->attributes = 0;
hpread.c:		  B_SET (&(list->attributes), ATTR_PROTECT);
hpread.c:		  B_SET (&(list->attributes), ATTR_PRIVATE);
hpread.c:	      list->field.name = VT (objfile) + fn_fieldp->dfield.name;
hpread.c:	      FIELD_BITPOS (list->field) = fn_fieldp->dfield.bitoffset;
hpread.c:		list->field.bitsize = fn_fieldp->dfield.bitlength;
hpread.c:		list->field.bitsize = 0;
hpread.c:	      list->field.type = memtype;
hpread.c:	      list->attributes = 0;
hpread.c:		  B_SET (&(list->attributes), ATTR_PROTECT);
hpread.c:		  B_SET (&(list->attributes), ATTR_PRIVATE);
hpread.c:	      list->field.name = VT (objfile) + fn_fieldp->dsvar.name;
hpread.c:	      FIELD_BITPOS (list->field) = 0;	/* FIXME is this always true? */
hpread.c:	      FIELD_BITSIZE (list->field) = 0;	/* use length from type */
hpread.c:	      FIELD_STATIC_KIND (list->field) = 0;
hpread.c:	      list->field.type = memtype;
hpread.c:	      list->attributes = 0;
hpread.c:	      list->field.name = VT (objfile) + fn_fieldp->ddvar.name;
hpread.c:	      FIELD_BITPOS (list->field) = 0;	/* FIXME is this always true? */
hpread.c:	      FIELD_BITSIZE (list->field) = 0;	/* use length from type */
hpread.c:	      FIELD_STATIC_KIND (list->field) = 0;
hpread.c:	      list->field.type = memtype;
hpread.c:	      list->attributes = 0;
hpread.c:	  list->field.name = VT (objfile) + fieldp->dfield.name;
hpread.c:	      SET_FIELD_PHYSNAME (list->field, NULL);
hpread.c:	      FIELD_BITPOS (list->field) = 0;
hpread.c:	      FIELD_BITSIZE (list->field) = 0;
hpread.c:	      FIELD_STATIC_KIND (list->field) = 0;
hpread.c:	      FIELD_BITPOS (list->field) = fieldp->dfield.bitoffset;
hpread.c:		FIELD_BITSIZE (list->field) = fieldp->dfield.bitlength;
hpread.c:		FIELD_BITSIZE (list->field) = 0;
hpread.c:	  FIELD_TYPE (list->field) = memtype;
hpread.c:	  list->attributes = 0;
hpread.c:	      B_SET (&(list->attributes), ATTR_PROTECT);
hpread.c:	      B_SET (&(list->attributes), ATTR_PRIVATE);
hpread.c:	  i_list->t = hpread_type_lookup (field, objfile);
hpread.c:  for (n = ninstantiations; i_list; i_list = i_list->next)
hpread.c:      TYPE_INSTANTIATION (type, n) = i_list->t;
hpread.c:  for (n = nfields, tmp_list = list; tmp_list; tmp_list = tmp_list->next)
hpread.c:      TYPE_FIELD (type, n) = tmp_list->field;
hpread.c:  for (n = n_fn_fields; fn_list; fn_list = fn_list->next)
hpread.c:      TYPE_FN_FIELDLIST (type, n) = fn_list->field;
hpread.c:  for (n = nfields, tmp_list = list; tmp_list; tmp_list = tmp_list->next)
hpread.c:      if (tmp_list->attributes)
hpread.c:	  if (B_TST (&(list->attributes), ATTR_VIRTUAL))
hpread.c:	  if (B_TST (&(list->attributes), ATTR_PRIVATE))
hpread.c:	  if (B_TST (&(list->attributes), ATTR_PROTECT))
hpread.c:	  list = list->next;
hpread.c:   * I.e., express both array-length and element-length in bits,
hpread.c:   * or express both array-length and element-length in bytes.
hpread.c:   * as: array of array of ..., we only need one subscript-type
hpux-thread.c:/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
i386bsd-nat.c:  t->to_fetch_registers = i386bsd_fetch_inferior_registers;
i386bsd-nat.c:  t->to_store_registers = i386bsd_store_inferior_registers;
i386bsd-tdep.c:/* Target-dependent code for i386 BSD's.
i386bsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-i386-netbsd") == 0)
i386bsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-i386-freebsd") == 0)
i386-cygwin-tdep.c:/* Target-dependent code for Cygwin running on i386's, for GDB.
i386fbsd-nat.c:  t->to_resume = i386fbsd_resume;
i386fbsd-nat.c:  t->to_pid_to_exec_file = fbsd_pid_to_exec_file;
i386fbsd-nat.c:  t->to_find_memory_regions = fbsd_find_memory_regions;
i386fbsd-nat.c:  t->to_make_corefile_notes = fbsd_make_corefile_notes;
i386fbsd-tdep.c:/* Target-dependent code for FreeBSD/i386.
i386fbsd-tdep.c:  /* FreeBSD uses -freg-struct-return by default.  */
i386gnu-tdep.c:/* Target-dependent code for the GNU Hurd.
i386-linux-nat.c:   target-specific data structure, but really, a particular GDB
i386-linux-nat.c:  t->to_resume = i386_linux_resume;
i386-linux-nat.c:  super_post_startup_inferior = t->to_post_startup_inferior;
i386-linux-nat.c:  t->to_post_startup_inferior = i386_linux_child_post_startup_inferior;
i386-linux-nat.c:  t->to_fetch_registers = i386_linux_fetch_inferior_registers;
i386-linux-nat.c:  t->to_store_registers = i386_linux_store_inferior_registers;
i386-linux-tdep.c:/* Target-dependent code for GNU/Linux i386.
i386-linux-tdep.h:/* Target-dependent code for GNU/Linux x86.
i386-nat.c:   value of the bit-field from DR7 which describes the length and
i386-nat.c:  CORE_ADDR addr = bp_tgt->placed_address;
i386-nat.c:  CORE_ADDR addr = bp_tgt->placed_address;
i386nbsd-tdep.c:/* Target-dependent code for NetBSD/i386.
i386nbsd-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386nbsd-tdep.c:  /* NetBSD uses -freg-struct-return by default.  */
i386nbsd-tdep.c:  /* NetBSD ELF uses -fpcc-struct-return by default.  */
i386-nto-tdep.c:/* Target-dependent code for QNX Neutrino x86.
i386-nto-tdep.c:  tdep->gregset->supply_regset (tdep->gregset, current_regcache, -1,
i386obsd-tdep.c:/* Target-dependent code for OpenBSD/i386.
i386obsd-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386obsd-tdep.c:  /* OpenBSD uses -freg-struct-return by default.  */
i386-sol2-tdep.c:/* Target-dependent code for Solaris x86.
i386-tdep.c:/* Intel 386 target-dependent stuff.
i386-tdep.c:/* This is the variable that is set with "set struct-convention", and
i386-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386-tdep.c:  const struct gdbarch_tdep *tdep = gdbarch_tdep (regset->arch);
i386-tdep.c:  add_setshow_enum_cmd ("struct-convention", no_class, valid_conventions,
i386-tdep.h:/* Target-dependent code for the i386.
i387-tdep.h:/* Target-dependent code for the i387.
ia64-linux-nat.c:  super_xfer_partial = t->to_xfer_partial;
ia64-linux-nat.c:  t->to_xfer_partial = ia64_linux_xfer_partial;
ia64-linux-tdep.c:/* Target-dependent code for the IA-64 for GDB, the GNU debugger.
ia64-tdep.c:/* Target-dependent code for the IA-64 for GDB, the GNU debugger.
ia64-tdep.c:  CORE_ADDR addr = bp_tgt->placed_address;
ia64-tdep.c:  memcpy (bp_tgt->shadow_contents, &instr, sizeof (instr));
ia64-tdep.c:  bp_tgt->placed_size = bp_tgt->shadow_len = sizeof (instr);
ia64-tdep.c:  CORE_ADDR addr = bp_tgt->placed_address;
ia64-tdep.c:  memcpy (&instr, bp_tgt->shadow_contents, sizeof instr);
ia64-tdep.c:		   !instores[indirect-32])
ia64-tdep.c:	      instores[indirect-32] = 1;
ia64-tdep.c:		   !instores[indirect-32])
ia64-tdep.c:	      instores[indirect-32] = 1;
ia64-tdep.c:  segbase = p_text->p_vaddr + load_base;
ia64-tdep.c:  if ((p_unwind->p_vaddr - p_text->p_vaddr) >= p_text->p_memsz)
ia64-tdep.c:  dip->start_ip = p_text->p_vaddr + load_base;
ia64-tdep.c:  dip->end_ip = dip->start_ip + p_text->p_memsz;
ia64-tdep.c:      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
ia64-tdep.c:	  if (strcmp (osect->the_bfd_section->name, ".dynamic") == 0)
ia64-tdep.c:      if (osect < faddr_sect->objfile->sections_end)
ia64-tdep.c:	  addr = osect->addr;
ia64-tdep.c:	  while (addr < osect->endaddr)
ia64-tdep.c:  if (faddr_sect && strcmp (faddr_sect->the_bfd_section->name, ".opd") == 0)
ia64-tdep.c:      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
ia64-tdep.c:	  if (strcmp (osect->the_bfd_section->name, ".opd") == 0)
ia64-tdep.c:      if (osect < faddr_sect->objfile->sections_end)
ia64-tdep.c:	  addr = osect->addr;
ia64-tdep.c:	  while (addr < osect->endaddr)
ia64-tdep.h:/* Target-dependent code for the ia64.
infcall.c:   with "set coerce-float-to-double 0".  */
infcall.c:    bpt->disposition = disp_del;
infcall.c:  add_setshow_boolean_cmd ("coerce-float-to-double", class_obscure,
inf-child.c:  t->to_shortname = "child";
inf-child.c:  t->to_longname = "Unix child process";
inf-child.c:  t->to_doc = "Unix child process (started by the \"run\" command).";
inf-child.c:  t->to_open = inf_child_open;
inf-child.c:  t->to_post_attach = inf_child_post_attach;
inf-child.c:  t->to_fetch_registers = inf_child_fetch_inferior_registers;
inf-child.c:  t->to_store_registers = inf_child_store_inferior_registers;
inf-child.c:  t->to_prepare_to_store = inf_child_prepare_to_store;
inf-child.c:  t->to_insert_breakpoint = memory_insert_breakpoint;
inf-child.c:  t->to_remove_breakpoint = memory_remove_breakpoint;
inf-child.c:  t->to_terminal_init = terminal_init_inferior;
inf-child.c:  t->to_terminal_inferior = terminal_inferior;
inf-child.c:  t->to_terminal_ours_for_output = terminal_ours_for_output;
inf-child.c:  t->to_terminal_save_ours = terminal_save_ours;
inf-child.c:  t->to_terminal_ours = terminal_ours;
inf-child.c:  t->to_terminal_info = child_terminal_info;
inf-child.c:  t->to_post_startup_inferior = inf_child_post_startup_inferior;
inf-child.c:  t->to_acknowledge_created_inferior = inf_child_acknowledge_created_inferior;
inf-child.c:  t->to_insert_fork_catchpoint = inf_child_insert_fork_catchpoint;
inf-child.c:  t->to_remove_fork_catchpoint = inf_child_remove_fork_catchpoint;
inf-child.c:  t->to_insert_vfork_catchpoint = inf_child_insert_vfork_catchpoint;
inf-child.c:  t->to_remove_vfork_catchpoint = inf_child_remove_vfork_catchpoint;
inf-child.c:  t->to_follow_fork = inf_child_follow_fork;
inf-child.c:  t->to_insert_exec_catchpoint = inf_child_insert_exec_catchpoint;
inf-child.c:  t->to_remove_exec_catchpoint = inf_child_remove_exec_catchpoint;
inf-child.c:  t->to_reported_exec_events_per_exec_call =
inf-child.c:  t->to_can_run = inf_child_can_run;
inf-child.c:  t->to_enable_exception_callback = inf_child_enable_exception_callback;
inf-child.c:  t->to_get_current_exception_event = inf_child_get_current_exception_event;
inf-child.c:  t->to_pid_to_exec_file = inf_child_pid_to_exec_file;
inf-child.c:  t->to_stratum = process_stratum;
inf-child.c:  t->to_has_all_memory = 1;
inf-child.c:  t->to_has_memory = 1;
inf-child.c:  t->to_has_stack = 1;
inf-child.c:  t->to_has_registers = 1;
inf-child.c:  t->to_has_execution = 1;
inf-child.c:  t->to_magic = OPS_MAGIC;
infcmd.c:#include "event-top.h"
infcmd.c:      for (; count > 0; count--)
infcmd.c:  single_inst      = arg->next->data.integer;
infcmd.c:  count            = arg->next->next->data.integer;
infcmd.c:      ui_out_field_fmt (uiout, "gdb-result-var", "$%d",
infcmd.c:  function = (struct symbol *) arg->next->data.pointer;
infcmd.c:  cleanups = (struct cleanup *) arg->next->next->data.pointer;
infcmd.c:  /* Take any necessary post-attaching actions for this platform.
inferior.h:   This is in order for argument-expansion to occur. E.g.,
inferior.h:   The catch-exec traps expected during start-up will
inf-loop.c:#include "event-loop.h"
inf-loop.c:#include "event-top.h"
inf-ptrace.c:  t->to_attach = inf_ptrace_attach;
inf-ptrace.c:  t->to_detach = inf_ptrace_detach;
inf-ptrace.c:  t->to_resume = inf_ptrace_resume;
inf-ptrace.c:  t->to_wait = inf_ptrace_wait;
inf-ptrace.c:  t->to_files_info = inf_ptrace_files_info;
inf-ptrace.c:  t->to_kill = inf_ptrace_kill;
inf-ptrace.c:  t->to_create_inferior = inf_ptrace_create_inferior;
inf-ptrace.c:  t->to_follow_fork = inf_ptrace_follow_fork;
inf-ptrace.c:  t->to_post_startup_inferior = inf_ptrace_post_startup_inferior;
inf-ptrace.c:  t->to_post_attach = inf_ptrace_post_attach;
inf-ptrace.c:  t->to_mourn_inferior = inf_ptrace_mourn_inferior;
inf-ptrace.c:  t->to_thread_alive = inf_ptrace_thread_alive;
inf-ptrace.c:  t->to_pid_to_str = normal_pid_to_str;
inf-ptrace.c:  t->to_stop = inf_ptrace_stop;
inf-ptrace.c:  t->to_xfer_partial = inf_ptrace_xfer_partial;
inf-ptrace.c:  t->to_fetch_registers = inf_ptrace_fetch_registers;
inf-ptrace.c:  t->to_store_registers = inf_ptrace_store_registers;
infptrace.c:/* Wait for a process to finish, possibly running a target-specific
infrun.c:/* Target-struct-independent code to start (run) and stop an inferior
infrun.c:      SOFTWARE_SINGLE_STEP (sig, 1 /*insert-breakpoints */ );
infrun.c:	       at not-yet-hit software breakpoint).  Since the
infrun.c:	  ui_out_field_fmt (uiout, "exit-code", "0%o",
inftarg.c:/* Target-vector operations for controlling Unix child processes, for GDB.
inf-ttrace.c:  page->refcount--;
inf-ttrace.c:      inf_ttrace_page_dict.count--;
inf-ttrace.c:	page->next->prev = page->prev;
inf-ttrace.c:  t->to_attach = inf_ttrace_attach;
inf-ttrace.c:  t->to_detach = inf_ttrace_detach;
inf-ttrace.c:  t->to_resume = inf_ttrace_resume;
inf-ttrace.c:  t->to_wait = inf_ttrace_wait;
inf-ttrace.c:  t->to_files_info = inf_ttrace_files_info;
inf-ttrace.c:  t->to_can_use_hw_breakpoint = inf_ttrace_can_use_hw_breakpoint;
inf-ttrace.c:  t->to_insert_watchpoint = inf_ttrace_insert_watchpoint;
inf-ttrace.c:  t->to_remove_watchpoint = inf_ttrace_remove_watchpoint;
inf-ttrace.c:  t->to_stopped_by_watchpoint = inf_ttrace_stopped_by_watchpoint;
inf-ttrace.c:  t->to_region_ok_for_hw_watchpoint =
inf-ttrace.c:  t->to_kill = inf_ttrace_kill;
inf-ttrace.c:  t->to_create_inferior = inf_ttrace_create_inferior;
inf-ttrace.c:  t->to_follow_fork = inf_ttrace_follow_fork;
inf-ttrace.c:  t->to_mourn_inferior = inf_ttrace_mourn_inferior;
inf-ttrace.c:  t->to_thread_alive = inf_ttrace_thread_alive;
inf-ttrace.c:  t->to_pid_to_str = inf_ttrace_pid_to_str;
inf-ttrace.c:  t->to_xfer_partial = inf_ttrace_xfer_partial;
interps.c:#include "event-loop.h"
interps.c:#include "event-top.h"
iq2000-tdep.c:/* Target-dependent code for the IQ2000 architecture, for GDB, the GNU
iq2000-tdep.c:   Convert a host-format address (CORE_ADDR) into a target pointer.  */
iq2000-tdep.c:   for the lowest-numbered line within the address range.  */
iq2000-tdep.c:   Called by gdb at start-up. */
jv-exp.c:   if the built-in stack extension method is used).
jv-exp.c:		  if (base < 0 || expout->elts[base+2].opcode != OP_TYPE)
jv-exp.c:		  type = expout->elts[base+1].type;
jv-exp.c:		    expout->elts[base + i] = expout->elts[base + i + 3];
jv-exp.c:      expout->elts[i + newlen] = expout->elts[i];
jv-exp.c:  memcpy (expout->elts + pos, new->elts, EXP_ELEM_TO_BYTES (newlen));
jv-exp.y:		  if (base < 0 || expout->elts[base+2].opcode != OP_TYPE)
jv-exp.y:		  type = expout->elts[base+1].type;
jv-exp.y:		    expout->elts[base + i] = expout->elts[base + i + 3];
jv-exp.y:      expout->elts[i + newlen] = expout->elts[i];
jv-exp.y:  memcpy (expout->elts + pos, new->elts, EXP_ELEM_TO_BYTES (newlen));
language.h:    /* Zero if the language has first-class arrays.  True if there are no
linux-fork.c:  if (fork_list != NULL && fork_list->next == NULL &&
linux-fork.c:      ptid_equal (fork_list->ptid, inferior_ptid))
linux-fork.c:	 died.  MVS comment cut-and-pasted from linux-nat.  */
linux-fork.c:   forks to debug.  Delete the exiting one and context-switch to the
linux-fork.c:  if (fork_list->next == NULL)
linux-fork.c:  /* Set/show restart-auto-finish: user-settable count.  Causes the
linux-nat.c:		 to insert -just- the single-step breakpoint in the
linux-nat.c:	 should never take this short-circuit if we are going to
linux-nat.c:       one and context-switch to the first available.  */
linux-nat.c:  if (lwp_list && lwp_list->next && is_lwp (ptid))
linux-nat.c:      && regset->collect_regset != NULL)
linux-nat.c:    regset->collect_regset (regset, current_regcache, -1,
linux-nat.c:      && regset->collect_regset != NULL)
linux-nat.c:    regset->collect_regset (regset, current_regcache, -1,
linux-nat.c:      && regset->collect_regset != NULL)
linux-nat.c:    regset->collect_regset (regset, current_regcache, -1,
linux-nat.c:  t->to_insert_fork_catchpoint = child_insert_fork_catchpoint;
linux-nat.c:  t->to_insert_vfork_catchpoint = child_insert_vfork_catchpoint;
linux-nat.c:  t->to_insert_exec_catchpoint = child_insert_exec_catchpoint;
linux-nat.c:  t->to_pid_to_exec_file = child_pid_to_exec_file;
linux-nat.c:  t->to_post_startup_inferior = linux_child_post_startup_inferior;
linux-nat.c:  t->to_post_attach = child_post_attach;
linux-nat.c:  t->to_follow_fork = child_follow_fork;
linux-nat.c:  t->to_find_memory_regions = linux_nat_find_memory_regions;
linux-nat.c:  t->to_make_corefile_notes = linux_nat_make_corefile_notes;
linux-nat.c:  super_xfer_partial = t->to_xfer_partial;
linux-nat.c:  t->to_xfer_partial = linux_xfer_partial;
linux-nat.c:  t->to_attach = linux_nat_attach;
linux-nat.c:  t->to_detach = linux_nat_detach;
linux-nat.c:  t->to_resume = linux_nat_resume;
linux-nat.c:  t->to_wait = linux_nat_wait;
linux-nat.c:  t->to_xfer_partial = linux_nat_xfer_partial;
linux-nat.c:  t->to_kill = linux_nat_kill;
linux-nat.c:  t->to_mourn_inferior = linux_nat_mourn_inferior;
linux-nat.c:  t->to_thread_alive = linux_nat_thread_alive;
linux-nat.c:  t->to_pid_to_str = linux_nat_pid_to_str;
linux-nat.c:  t->to_has_thread_control = tc_schedlock;
linux-thread-db.c:       post-processing and bail out early.  */
m2-exp.c:   if the built-in stack extension method is used).
m2-exp.c:       /* Built-in BOOLEAN type.  This is sort of a hack. */
m2-exp.y:       /* Built-in BOOLEAN type.  This is sort of a hack. */
m2-lang.c:/* The built-in types of Modula-2.  */
m2-lang.c:  0,				/* arrays are first-class (not c-style) */
m32c-tdep.c:/* Renesas M32C target-dependent code for GDB, the GNU debugger.
m32c-tdep.c:  gdb_assert (st->next_addr - st->scan_pc < sizeof (st->insn));
m32c-tdep.c:  return st->insn[st->next_addr++ - st->scan_pc];
m32c-tdep.c:    case 0x0: sd.reg = (size == 1 ? &st->r0 : &st->r0); break;
m32c-tdep.c:    case 0x1: sd.reg = (size == 1 ? &st->r0 : &st->r1); break;
m32c-tdep.c:    case 0x2: sd.reg = (size == 1 ? &st->r1 : &st->r2); break;
m32c-tdep.c:    case 0x3: sd.reg = (size == 1 ? &st->r1 : &st->r3); break;
m32c-tdep.c:    case 0x4: sd.reg = &st->a0; break;
m32c-tdep.c:    case 0x5: sd.reg = &st->a1; break;
m32c-tdep.c:    case 0x6: sd.addr = st->a0; break;
m32c-tdep.c:    case 0x7: sd.addr = st->a1; break;
m32c-tdep.c:    case 0x8: sd.addr = pv_add_constant (st->a0, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0x9: sd.addr = pv_add_constant (st->a1, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0xa: sd.addr = pv_add_constant (st->sb, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0xb: sd.addr = pv_add_constant (st->fb, m32c_sdisp8 (st)); break;
m32c-tdep.c:    case 0xc: sd.addr = pv_add_constant (st->a0, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0xd: sd.addr = pv_add_constant (st->a1, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0xe: sd.addr = pv_add_constant (st->sb, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0x12: sd.reg = &st->r0; break;
m32c-tdep.c:    case 0x13: sd.reg = &st->r1; break;
m32c-tdep.c:    case 0x10: sd.reg = ((size == 1) ? &st->r0 : &st->r2); break;
m32c-tdep.c:    case 0x11: sd.reg = ((size == 1) ? &st->r1 : &st->r3); break;
m32c-tdep.c:    case 0x02: sd.reg = &st->a0; break;
m32c-tdep.c:    case 0x03: sd.reg = &st->a1; break;
m32c-tdep.c:    case 0x00: sd.addr = st->a0; break;
m32c-tdep.c:    case 0x01: sd.addr = st->a1; break;
m32c-tdep.c:    case 0x04: sd.addr = pv_add_constant (st->a0, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0x05: sd.addr = pv_add_constant (st->a1, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0x06: sd.addr = pv_add_constant (st->sb, m32c_udisp8 (st)); break;
m32c-tdep.c:    case 0x07: sd.addr = pv_add_constant (st->fb, m32c_sdisp8 (st)); break;
m32c-tdep.c:    case 0x08: sd.addr = pv_add_constant (st->a0, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0x09: sd.addr = pv_add_constant (st->a1, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0x0a: sd.addr = pv_add_constant (st->sb, m32c_udisp16 (st)); break;
m32c-tdep.c:    case 0x0b: sd.addr = pv_add_constant (st->fb, m32c_sdisp16 (st)); break;
m32c-tdep.c:    case 0x0c: sd.addr = pv_add_constant (st->a0, m32c_udisp24 (st)); break;
m32c-tdep.c:    case 0x0d: sd.addr = pv_add_constant (st->a1, m32c_udisp24 (st)); break;
m32c-tdep.c:  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);
m32c-tdep.c:          && ! pv_area_find_reg (st->stack, st->arch, value.reg, 0));
m32c-tdep.c:  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);
m32c-tdep.c:	  && !pv_area_find_reg (st->stack, st->arch, value.reg, 0)
m32c-tdep.c:  struct gdbarch_tdep *tdep = gdbarch_tdep (st->arch);
m32c-tdep.c:    (pv_is_register (st->sp, tdep->sp->num)
m32c-tdep.c:     && (! (src & 0x01) || pv_is_register_k (st->fb, tdep->fb->num, 0))
m32c-tdep.c:     && (! (src & 0x02) || pv_is_register_k (st->sb, tdep->sb->num, 0))
m32c-tdep.c:     && (! (src & 0x04) || pv_is_register_k (st->a1, tdep->a1->num, 0))
m32c-tdep.c:     && (! (src & 0x08) || pv_is_register_k (st->a0, tdep->a0->num, 0))
m32c-tdep.c:     && (! (src & 0x10) || pv_is_register_k (st->r3, tdep->r3->num, 0))
m32c-tdep.c:     && (! (src & 0x20) || pv_is_register_k (st->r2, tdep->r2->num, 0))
m32c-tdep.c:     && (! (src & 0x40) || pv_is_register_k (st->r1, tdep->r1->num, 0))
m32c-tdep.c:     && (! (src & 0x80) || pv_is_register_k (st->r0, tdep->r0->num, 0)));
m32r-linux-nat.c:  t->to_fetch_registers = m32r_linux_fetch_inferior_registers;
m32r-linux-nat.c:  t->to_store_registers = m32r_linux_store_inferior_registers;
m32r-linux-tdep.c:/* Target-dependent code for GNU/Linux m32r.
m32r-rom.c:	      memcpy (&inet_addr.s_addr, hostent->h_addr,
m32r-rom.c:	      server_addr = (char *) inet_ntoa (hostent->h_addr);
m32r-stub.c:  B09rxxxx	BNEZ	branch not-equal-zero
m32r-stub.c:  Br1rxxxx	BNE	branch not-equal
m32r-stub.c:  7Dxx		BNC	branch not-condition
m32r-stub.c:  FDxxxxxx	BNC	branch not-condition (long)
m32r-stub.c:     cast the most-significant byte of the return offset to char.
m32r-stub.c:  else				/* "first-slot" instruction */
m32r-stub.c:  psw->bsm = psw->bie = psw->bc = 0;	/* zero post-trap values */
m32r-tdep.c:/* Target-dependent code for Renesas M32R, for GDB.
m32r-tdep.c:  CORE_ADDR addr = bp_tgt->placed_address;
m32r-tdep.c:  gdb_byte *contents_cache = bp_tgt->shadow_contents;
m32r-tdep.c:  bp_tgt->placed_size = bp_tgt->shadow_len = 4;
m32r-tdep.c:  CORE_ADDR addr = bp_tgt->placed_address;
m32r-tdep.c:  gdb_byte *contents_cache = bp_tgt->shadow_contents;
m32r-tdep.c:     STRUCT_ADDR) will consume the first argument-passing register.
m32r-tdep.c:	  /* value gets right-justified in the register or stack word */
m32r-tdep.h:/* Target-dependent code for Renesas M32R, for GDB.
m68hc11-tdep.c:/* Target-dependent code for Motorola 68HC11 & 68HC12
m68hc11-tdep.c:  /* Sequences to save a soft-register.  */
m68hc11-tdep.c:  /* Add 1 here to adjust for the post-decrement nature of the push
m68kbsd-nat.c:  t->to_fetch_registers = m68kbsd_fetch_inferior_registers;
m68kbsd-nat.c:  t->to_store_registers = m68kbsd_store_inferior_registers;
m68kbsd-tdep.c:/* Target-dependent code for Motorola 68000 BSD's.
m68kbsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-m68k-netbsd") == 0
m68kbsd-tdep.c:      || strcmp (bfd_get_target (abfd), "a.out-m68k4k-netbsd") == 0)
m68klinux-nat.c:  t->to_fetch_registers = m68k_linux_fetch_inferior_registers;
m68klinux-nat.c:  t->to_store_registers = m68k_linux_store_inferior_registers;
m68klinux-tdep.c:/* Motorola m68k target-dependent support for GNU/Linux.
m68klinux-tdep.c:     The frame ID's code address should be the start-address of the
m68k-tdep.c:/* Target-dependent code for the Motorola 68000 series.
m68k-tdep.c:   (68881/2) or built-in (68040/68060).  That's why System V release 4
m68k-tdep.c:   %d0/%d1 instead of in memory by using -freg-struct-return.  This is
m68k-tdep.h:/* Target-dependent code for the Motorola 68000 series.
m68k-tdep.h:/* Target-dependent structure in gdbarch.  */
m88kbsd-nat.c:  t->to_fetch_registers = m88kbsd_fetch_inferior_registers;
m88kbsd-nat.c:  t->to_store_registers = m88kbsd_store_inferior_registers;
m88k-tdep.c:/* Target-dependent code for the Motorola 88000 series.
m88k-tdep.h:/* Target-dependent code for the Motorola 88000 series.
macroexp.c:  int original_dest_len = dest->len;
macroexp.c:  gdb_assert (dest->last_token != -1);
macroexp.c:  if (dest->last_token == original_dest_len)
macroexp.c:      dest->last_token = original_dest_len + src->last_token;
macroexp.c:                      dest->text + dest->last_token,
macroexp.c:                      dest->len - dest->last_token);
macroexp.c:          == dest->text + original_dest_len))
macroexp.c:      dest->last_token = original_dest_len + src->last_token;
macroexp.c:  dest->len = original_dest_len;
macroexp.c:                      dest->text + dest->last_token,
macroexp.c:                      dest->len - dest->last_token);
macroexp.c:          == dest->text + original_dest_len))
macroexp.c:      dest->last_token = original_dest_len + 1 + src->last_token;
macroexp.c:  for (; list; list = list->next)
macroexp.c:    if (strcmp (name, list->name) == 0)
macroexp.c:  gdb_assert (dest->len == 0);
macroexp.c:  dest->last_token = 0;
macroexp.c:          dest->last_token = dest->len;
macroexp.c:  gdb_assert (src_first->shared);
macroexp.c:  gdb_assert (src_rest->shared);
macroexp.c:  gdb_assert (! dest->shared);
macroexp.c:  if (src_first->is_identifier)
macroexp.c:      char *id = xmalloc (src_first->len + 1);
macroexp.c:      memcpy (id, src_first->text, src_first->len);
macroexp.c:      id[src_first->len] = 0;
macroexp.c:  gdb_assert (! dest->shared);
macroexp.c:          dest->last_token = dest->len;
macroexp.c:      dest->last_token = dest->len;
macroexp.h:   We need this expand-one-token-at-a-time interface in order to
macrotab.c:  if (t->obstack)
macrotab.c:    return obstack_alloc (t->obstack, size);
macrotab.c:  gdb_assert (! t->obstack);
macrotab.c:  if (t->bcache)
macrotab.c:    return bcache (addr, len, t->bcache);
macrotab.c:  gdb_assert (! t->bcache);
macrotab.c:  gdb_assert (! t->main_source);
macrotab.c:  t->main_source = new_source_file (t, filename);
macrotab.c:  return t->main_source;
macrotab.c:  gdb_assert (t->main_source);
macrotab.c:  return t->main_source;
macrotab.c:  n = splay_tree_lookup (t->definitions, (splay_tree_key) &query);
macrotab.c:      splay_tree_node pred = splay_tree_predecessor (t->definitions,
macrotab.c:  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
macrotab.c:  splay_tree_insert (t->definitions, (splay_tree_key) k, (splay_tree_value) d);
macrotab.c:  t->obstack = obstack;
macrotab.c:  t->bcache = b;
macrotab.c:  t->main_source = NULL;
macrotab.c:  t->definitions = (splay_tree_new_with_allocator
macrotab.h:   least-nested inclusion --- the one closest to the main source file.  */
macrotab.h:/* Record an object-like #definition (i.e., one with no parameter list).
main.c:#include "event-loop.h"
main.c:  int argc = context->argc;
main.c:  char **argv = context->argv;
main.c:  interpreter_p = xstrdup (context->interpreter_p);
main.c:  /* Do any host- or target-specific hacks.  This is used for i960 targets
MAINTAINERS:Jerome Guitton					guitton@act-europe.fr
maint.c:      maint_print_section_info (name, flags, addr, endaddr, asect->filepos);
maint.c:  flagword flags = bfd_get_section_flags (abfd, asect->the_bfd_section);
maint.c:  const char *name = bfd_section_name (abfd, asect->the_bfd_section);
maint.c:      maint_print_section_info (name, flags, asect->addr, asect->endaddr, 
maint.c:			  asect->the_bfd_section->filepos);
maint.c:    printf_filtered (_("no symbol at %s:0x%s\n"), sect->name, paddr (address));
Makefile.in:GDB_WARN_CFLAGS_NO_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/ -Wformat-nonliteral / /g"`
Makefile.in:# M{H,T}_CFLAGS, if defined, have host- and target-dependent CFLAGS
Makefile.in:# {X,T}M_CLIBS, defined in *config files, have host- and target-dependent libs.
Makefile.in:# host-dependent makefile fragment might need to use something else
Makefile.in:# Host and target-dependent makefile fragments come in here.
Makefile.in:# End of host and target-dependent makefile fragments
Makefile.in:	elfread.c environ.c eval.c event-loop.c event-top.c expprint.c \
Makefile.in:	target.c target-memory.c thread.c top.c tracepoint.c \
Makefile.in:event_loop_h = event-loop.h
Makefile.in:event_top_h = event-top.h
Makefile.in:	event-loop.o event-top.o inf-loop.o completer.o \
Makefile.in:	prologue-value.o memory-map.o xml-support.o target-memory.o
Makefile.in:test-cp-name-parser.o: cp-name-parser.c $(safe_ctype_h) $(libiberty_h) \
Makefile.in:		-o test-cp-name-parser.o cp-name-parser.c
Makefile.in:test-cp-name-parser$(EXEEXT): test-cp-name-parser.o $(LIBIBERTY)
Makefile.in:	$(CC_LD) $(INTERNAL_LDFLAGS) -o test-cp-name-parser$(EXEEXT) \
Makefile.in:		test-cp-name-parser.o $(LIBIBERTY)
Makefile.in:	rm -f test-cp-name-parser$(EXEEXT)
Makefile.in:# FIXME: cagney/2003-08-10: "monitor.c" gets -Wformat-nonliteral
Makefile.in:# Do not try to build "printcmd.c" with -Wformat-nonliteral.  It manually
Makefile.in:event-loop.o: event-loop.c $(defs_h) $(event_loop_h) $(event_top_h) \
Makefile.in:event-top.o: event-top.c $(defs_h) $(top_h) $(inferior_h) $(target_h) \
Makefile.in:target-memory.o: target-memory.c $(defs_h) $(vec_h) $(target_h) \
mdebugread.c:      printf_filtered (_("Reading in symbols for %s..."), pst->filename);
mdebugread.c:  psymtab_to_symtab_1 (pst, pst->filename);
mdebugread.c:  scan_file_globals (pst->objfile);
mdebugread.c:	/* Common code for handling struct, union, enum, and/or as-yet-
mdebugread.c:	       enumerators and gcc -gcoff -fshort-enums, but these cases
mdebugread.c:  if (t->bt >= (sizeof (map_bt) / sizeof (*map_bt)))
mdebugread.c:      basic_type_complaint (t->bt, sym_name);
mdebugread.c:  if (map_bt[t->bt])
mdebugread.c:      tp = *map_bt[t->bt];
mdebugread.c:      switch (t->bt)
mdebugread.c:	  basic_type_complaint (t->bt, sym_name);
mdebugread.c:  if (t->fBitfield)
mdebugread.c:	  if (t->bt == btShort && width == 8)
mdebugread.c:	  else if (t->bt == btUShort && width == 8)
mdebugread.c:	  else if (t->bt == btEnum)
mdebugread.c:  if (t->bt == btIndirect)
mdebugread.c:  if (t->bt == btStruct ||
mdebugread.c:      t->bt == btUnion ||
mdebugread.c:      t->bt == btEnum ||
mdebugread.c:      t->bt == btSet)
mdebugread.c:  if (t->bt == btRange)
mdebugread.c:  if (t->bt == btTypedef)
mdebugread.c:  if (t->bt == btRange)
mdebugread.c:      if (t->tq != tqNil) \
mdebugread.c:	ax += upgrade_type(fd, &tp, t->tq, ax, bigend, sym_name); \
mdebugread.c:      if (!t->continued)
mdebugread.c:  if (t->continued)
mdebugread.c:         ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (pst->objfile)).
mdebugread.c:      adr = pst->textlow + pr->adr - lowest_pdr_addr;
mdebugread.c:	  if (lt->nitems >= maxlines)
mdebugread.c:/* Master parsing procedure for first-pass reading of file symbols
mdebugread.c:      pst->read_symtab_private = ((char *)
mdebugread.c:      memset (pst->read_symtab_private, 0, sizeof (struct symloc));
mdebugread.c:      pst->read_symtab = mdebug_psymtab_to_symtab;
mdebugread.c:      pst->texthigh = pst->textlow;
mdebugread.c:			  && (pst->textlow == 0 || procaddr < pst->textlow))
mdebugread.c:			    pst->textlow = procaddr;
mdebugread.c:			  if (high > pst->texthigh)
mdebugread.c:			    pst->texthigh = high;
mdebugread.c:		      if (pst && strcmp (namestring, pst->filename) == 0)
mdebugread.c:		       pst->texthigh to the proper value, which is
mdebugread.c:		    if (sh.value > save_pst->texthigh)
mdebugread.c:		      save_pst->texthigh = sh.value;
mdebugread.c:		      && (pst->textlow == 0 || procaddr < pst->textlow))
mdebugread.c:		    pst->textlow = procaddr;
mdebugread.c:		  if (high > pst->texthigh)
mdebugread.c:		    pst->texthigh = high;
mdebugread.c:					   -1, save_pst->texthigh,
mdebugread.c:	  && save_pst->textlow != 0
mdebugread.c:		&& save_pst->textlow >= pst->textlow
mdebugread.c:		&& save_pst->textlow < pst->texthigh
mdebugread.c:		&& save_pst->texthigh > pst->texthigh)
mdebugread.c:      pst->number_of_dependencies = 0;
mdebugread.c:      pst->dependencies =
mdebugread.c:	  pst->dependencies[pst->number_of_dependencies++] = fdr_to_pst[rh].pst;
mdebugread.c:  if (pst->readin)
mdebugread.c:  pst->readin = 1;
mdebugread.c:     that by setting pst->readin before this point.  */
mdebugread.c:  for (i = 0; i < pst->number_of_dependencies; i++)
mdebugread.c:    if (!pst->dependencies[i]->readin)
mdebugread.c:			     pst->dependencies[i]->filename);
mdebugread.c:	psymtab_to_symtab_1 (pst->dependencies[i],
mdebugread.c:			     pst->dependencies[i]->filename);
mdebugread.c:  if (pst->n_global_syms == 0 && pst->n_static_syms == 0
mdebugread.c:      && pst->textlow == 0 && pst->texthigh == 0)
mdebugread.c:  current_objfile = pst->objfile;
mdebugread.c:		      valu += ANOFFSET (pst->section_offsets,
mdebugread.c:					SECT_OFF_TEXT (pst->objfile));
mdebugread.c:		      st = end_symtab (valu, pst->objfile,
mdebugread.c:				       SECT_OFF_TEXT (pst->objfile));
mdebugread.c:					  pst->section_offsets, pst->objfile);
mdebugread.c:				      pst->section_offsets, pst->objfile);
mdebugread.c:		  valu += ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (pst->objfile));
mdebugread.c:	  st = end_symtab (pst->texthigh, pst->objfile, SECT_OFF_TEXT (pst->objfile));
mdebugread.c:	  st = new_symtab ("unknown", 0, pst->objfile);
mdebugread.c:	  st = new_symtab (pst->filename, maxlines, pst->objfile);
mdebugread.c:	  st->language = PST_PRIVATE (pst)->pst_language;
mdebugread.c:      psymtab_language = st->language;
mdebugread.c:      BLOCK_START (top_stack->cur_block) = pst->textlow;
mdebugread.c:				sym_ptr, fh->fBigendian, pst->section_offsets, pst->objfile);
mdebugread.c:	parse_external (ext_ptr, fh->fBigendian, pst->section_offsets, pst->objfile);
mdebugread.c:			   st->filename, n_undef_symbols);
mdebugread.c:      st->primary = 1;
mdebugread.c:  pst->symtab = st;
mdebugread.c:  lt->item[lt->nitems].line = lineno;
mdebugread.c:  lt->item[lt->nitems++].pc = adr << 2;
mdebugread.c:					 + ((lt->nitems - 1)
mdebugread.c:					    * sizeof (lt->item))));
memattr.c:   a target-provided list to a local list, if necessary.  */
memattr.c:  /* If we don't have a target-provided region list yet, then
memattr.c:   target-provided list, if necessary.  */
memattr.c:       * to cut-and-paste the list of attributes when defining a new
memattr.c:target-based.\n\
memattr.h:  /* enables host-side caching of memory region data */
mem-break.c:  bp = BREAKPOINT_FROM_PC (&bp_tgt->placed_address, &bp_tgt->placed_size);
mem-break.c:  bp_tgt->shadow_len = bp_tgt->placed_size;
mem-break.c:  val = target_read_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
mem-break.c:			    bp_tgt->placed_size);
mem-break.c:    val = target_write_memory (bp_tgt->placed_address, bp,
mem-break.c:			       bp_tgt->placed_size);
mem-break.c:  return target_write_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
mem-break.c:			      bp_tgt->placed_size);
mingw-hdep.c:   unfortunately this includes all socket-related error codes.
mingw-hdep.c:	Sleep (timeout->tv_sec * 1000 + timeout->tv_usec / 1000);
mingw-hdep.c:				  ? (timeout->tv_sec * 1000
mingw-hdep.c:				     + timeout->tv_usec / 1000)
minsyms.c:   constructor functions --- "in-charge", "not-in-charge", and
minsyms.c:         is indexed by mcount and not mcount-1. */
mips64obsd-nat.c:  t->to_fetch_registers = mips64obsd_fetch_inferior_registers;
mips64obsd-nat.c:  t->to_store_registers = mips64obsd_store_inferior_registers;
mips64obsd-tdep.c:/* Target-dependent code for OpenBSD/mips64.
mips-irix-tdep.c:/* Target-dependent code for the MIPS architecture running on IRIX,
mips-linux-nat.c:  super_fetch_registers = t->to_fetch_registers;
mips-linux-nat.c:  super_store_registers = t->to_store_registers;
mips-linux-nat.c:  t->to_fetch_registers = mips64_linux_fetch_registers;
mips-linux-nat.c:  t->to_store_registers = mips64_linux_store_registers;
mips-linux-tdep.c:/* Target-dependent code for GNU/Linux on MIPS processors.
mips-linux-tdep.h:/* Target-dependent code for GNU/Linux on MIPS processors.
mips-mdebug-tdep.c:/* Target-dependent code for the MDEBUG MIPS architecture, for GDB,
mips-mdebug-tdep.h:/* Target-dependent code for the MDEBUG MIPS architecture, for GDB,
mipsnbsd-nat.c:  t->to_fetch_registers = mipsnbsd_fetch_inferior_registers;
mipsnbsd-nat.c:  t->to_store_registers = mipsnbsd_store_inferior_registers;
mipsnbsd-tdep.c:/* Target-dependent code for NetBSD/mips.
mips-tdep.c:/* Target-dependent code for the MIPS architecture, for GDB, the GNU Debugger.
mips-tdep.c:     storing a left-aligned 32-bit value in each?  */
mips-tdep.c:      /* A scalar extract each part but least-significant-byte
mips-tdep.c:      /* A scalar extract each part but least-significant-byte
mips-tdep.c:      /* A scalar extract each part but least-significant-byte
mips-tdep.c:  add_setshow_boolean_cmd ("remote-mips64-transfers-32bit-regs", class_obscure,
mips-tdep.h:/* Target-dependent header for the MIPS architecture, for GDB, the GNU Debugger.
mn10300-linux-tdep.c:/* Target-dependent code for the Matsushita MN10300 for GDB, the GNU debugger.
mn10300-linux-tdep.c:			 &fpregset->fpcr);
mn10300-linux-tdep.c:			 &fpregset->fpregs[regnum - E_FS0_REGNUM]);
mn10300-linux-tdep.c:			  &fpregset->fpcr);
mn10300-linux-tdep.c:			  &fpregset->fpregs[regnum - E_FS0_REGNUM]);
mn10300-tdep.c:/* Target-dependent code for the Matsushita MN10300 for GDB, the GNU debugger.
mn10300-tdep.c:       post-increment addressing to save the FP registers.
mn10300-tdep.c:			 the -fomit-frame-pointer or -O3 options, the
mn10300-tdep.h:/* Target-dependent interface for Matsushita MN10300 for GDB, the GNU debugger.
monitor.c:	      immediate_quit--;
monitor.c:	      immediate_quit--;
monitor.c:  CORE_ADDR addr = bp_tgt->placed_address;
monitor.c:  bp_tgt->placed_address = addr;
monitor.c:  bp_tgt->placed_size = bplen;
monitor.c:  CORE_ADDR addr = bp_tgt->placed_address;
mt-tdep.c:/* Target-dependent code for Morpho mt processor, for GDB.
mt-tdep.c:      /* Right-justify the value in an aligned-length buffer.  */
nbsd-tdep.c:/* Common target-dependent code for NetBSD systems.
nbsd-tdep.h:/* Common target-dependent definitions for NetBSD systems.
NEWS:* The "set trust-readonly-sections" command works again.  This command was
NEWS:init-if-undefined		Initialize a convenience variable, but
NEWS:GDB now supports the not-quite-ieee VAX F and D floating point formats.
NEWS:compatibility module that allowed out-of-date configurations to
NEWS:AT&T 3b1/Unix pc				m68*-att-*
NEWS:* TUI (Text-mode User Interface) built-in (also included in GDB 6.1)
NEWS:The TUI (Text-mode User Interface) is now built as part of a default
NEWS:* "set prompt-escape-char" command deleted.
NEWS:The command "set prompt-escape-char" has been deleted.  This command,
NEWS:AT&T 3b1/Unix pc				m68*-att-*
NEWS:Sequent family					i[3456]86-sequent-sysv4*
NEWS:						i[3456]86-sequent-sysv*
NEWS:						i[3456]86-sequent-bsd*
NEWS:Tsqware Sparclet				sparclet-*-*
NEWS:Sequent family					i[3456]86-sequent-sysv4*
NEWS:						i[3456]86-sequent-sysv*
NEWS:						i[3456]86-sequent-bsd*
NEWS:Tsqware Sparclet				sparclet-*-*
NEWS:in an improvement in the start-up time of multi-threaded, shared
NEWS:* New command "set trust-readonly-sections on[off]".
NEWS:There is a new `operate-and-get-next' function bound to `C-o'.
NEWS:It is now possible to define a post-hook for a command as well as a
NEWS:debugging print-outs in functions that insert, remove, and test
NEWS:TUI, the Text-mode User Interface, is now documented in the manual.
NEWS:The command ``set remote-mips64-transfers-32bit-regs on'' has been
NEWS:Thanks to a major code donation from Hewlett-Packard, GDB now has much
NEWS:further additions to the target-side stub; see tracepoint.c and
NEWS:Tsqware Sparclet				sparclet-*-*
NEWS:additional target-side support and use "overlay load-target" to bring
NEWS:extensive support in the target-side debugging stub.  Tracing mode
NEWS:Matra Sparclet					sparclet-*-*
NEWS:* dont-repeat command
NEWS:If a user-defined command includes the command `dont-repeat', then the
NEWS:mips-idt-ecoff target has been tested.
NEWS:Sequent PTX4				i[34]86-sequent-ptx4
NEWS:IDT MIPS board over serial line		mips-idt-ecoff
NEWS:Some versions of gcc come with an assembler post-processor called
NEWS:quite useful for catching tough ``bit-spreader'' or pointer misuse
nto-procfs.c:/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
nto-procfs.c:  return procfs_breakpoint (bp_tgt->placed_address, _DEBUG_BREAK_EXEC, 0);
nto-procfs.c:  return procfs_breakpoint (bp_tgt->placed_address, _DEBUG_BREAK_EXEC, -1);
nto-procfs.c:  return procfs_breakpoint (bp_tgt->placed_address,
nto-procfs.c:  return procfs_breakpoint (bp_tgt->placed_address,
nto-procfs.c:  flags = _DEBUG_FLAG_KLC;	/* Kill-on-Last-Close flag.  */
nto-procfs.c:      /* warning( "Failed to set Kill-on-Last-Close flag: errno = %d(%s)\n",
objc-exp.c:   if the built-in stack extension method is used).
objc-exp.c:			  while (count-- > 0)
objc-exp.y:			  while (count-- > 0)
objc-lang.c:"The 'print-object' command requires an argument (an Objective-C object)");
objc-lang.c: * IN_SOLIB_TRAMPOLINE macros, which are resolved in the target-
objc-lang.c:  add_com ("print-object", class_vars, print_object_command, 
objc-lang.c:  add_com_alias ("po", "print-object", class_vars, 1);
objc-lang.c:  object->isa = read_memory_unsigned_integer (addr, 4);
objfiles.c:      /* Examination of non-executable.o files.  Short-circuit this stuff.  */
objfiles.h:    /* Hook for target-architecture-specific information.  This must
obsd-tdep.c:/* Target-dependent code for OpenBSD.
obsd-tdep.h:/* Target-dependent code for OpenBSD.
observer.c:  observer_list->next = *subject;
observer.c:  observer_list->observer->notify = notify;
observer.c:  observer_list->observer->data = data;
observer.c:  return observer_list->observer;
observer.c:/* The following code is only used to unit-test the observers from our
ocd.c:  immediate_quit--;
ocd.c:  bp_tgt->placed_size = bp_tgt->shadow_len = sizeof (break_insn);
ocd.c:  val = target_read_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
ocd.c:			    bp_tgt->placed_size);
ocd.c:    val = target_write_memory (bp_tgt->placed_address, break_insn,
ocd.c:			       bp_tgt->placed_size);
ocd.c:  return target_write_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
ocd.c:			      bp_tgt->placed_size);
parse.c:  expout->elts[expout_ptr++] = expelt;
parse.c:  strdata = (char *) &expout->elts[expout_ptr];
parse.c:  strdata = (char *) &expout->elts[expout_ptr];
parse.c:  expout->language_defn = current_language;
parse.c:  expout->nelts = expout_ptr;
parse.c:/* A post-parser that does nothing */
parser-defs.h:/* A string token, either a char-string or bit-string.  Char-strings are
parser-defs.h:    /* Pointer to first byte of char-string or first bit of bit-string */
parser-defs.h:    /* Length of string in bytes for char-string or bits for bit-string */
p-exp.c:   if the built-in stack extension method is used).
p-exp.c:			  while (count-- > 0)
p-exp.y:			  while (count-- > 0)
ppc-linux-nat.c:	 the secondhalf of such a slot-pair (hence +1).  For 64-bit,
ppc-linux-nat.c:  t->to_fetch_registers = ppc_linux_fetch_inferior_registers;
ppc-linux-nat.c:  t->to_store_registers = ppc_linux_store_inferior_registers;
ppc-linux-nat.c:  t->to_can_use_hw_breakpoint = ppc_linux_check_watch_resources;
ppc-linux-nat.c:  t->to_region_ok_for_hw_watchpoint = ppc_linux_region_ok_for_hw_watchpoint;
ppc-linux-nat.c:  t->to_insert_watchpoint = ppc_linux_insert_watchpoint;
ppc-linux-nat.c:  t->to_remove_watchpoint = ppc_linux_remove_watchpoint;
ppc-linux-nat.c:  t->to_stopped_by_watchpoint = ppc_linux_stopped_by_watchpoint;
ppc-linux-nat.c:  t->to_stopped_data_address = ppc_linux_stopped_data_address;
ppc-linux-tdep.c:/* Target-dependent code for GDB, the GNU debugger.
ppc-linux-tdep.c:  if (!sect || strcmp (sect->the_bfd_section->name, ".plt") != 0)
ppc-linux-tdep.c:  objfile = sect->objfile;
ppc-linux-tdep.c:      const char *secname = sect->the_bfd_section->name;
ppc-linux-tdep.c:	plt_start = sect->addr;
ppc-linux-tdep.c:	num_slots = ((int) sect->endaddr - (int) sect->addr) / 12;
ppc-linux-tdep.c:	symtab = sect->addr;
ppc-linux-tdep.c:	strtab = sect->addr;
ppc-linux-tdep.c:  if (strcmp (sect->the_bfd_section->name, ".text") == 0)
ppc-linux-tdep.c:  CORE_ADDR addr = bp_tgt->placed_address;
ppc-linux-tdep.c:    val = target_write_memory (addr, bp_tgt->shadow_contents, bplen);
ppc-linux-tdep.c:   storing their values in REGCACHE.  Note that some are left-aligned,
ppc-linux-tdep.c:     eight-byte long doubles.  GCC only recently got 128-bit long
ppcnbsd-nat.c:  t->to_fetch_registers = ppcnbsd_fetch_inferior_registers;
ppcnbsd-nat.c:  t->to_store_registers = ppcnbsd_store_inferior_registers;
ppcnbsd-tdep.c:/* Target-dependent code for NetBSD/powerpc.
ppcnbsd-tdep.h:/* Target-dependent code for NetBSD/powerpc.
ppcobsd-nat.c:  t->to_fetch_registers = ppcobsd_fetch_registers;
ppcobsd-nat.c:  t->to_store_registers = ppcobsd_store_registers;
ppcobsd-tdep.c:/* Target-dependent code for OpenBSD/powerpc.
ppcobsd-tdep.h:/* Target-dependent code for OpenBSD/powerpc.
ppc-sysv-tdep.c:/* Target-dependent code for PowerPC systems using the SVR4 ABI
ppc-sysv-tdep.c:	 than or equal to 8 bytes..  Instead of left-aligning, it
ppc-sysv-tdep.c:	 right-aligns the data into the buffer formed by r3, r4.  */
ppc-sysv-tdep.c:	  /* The value is right-padded to 8 bytes and then loaded, as
ppc-tdep.h:/* Target-dependent code for GDB, the GNU debugger.
printcmd.c:     save some memory, but for many debug format--ELF/DWARF or
printcmd.c:	   i--, count--)
printcmd.c:    sect = osect->the_bfd_section;
printcmd.c:    if (osect->addr <= sect_addr && sect_addr < osect->endaddr &&
printcmd.c:	printf_filtered (_("section %s"), sect->name);
printcmd.c:	if (d->next->number == num)
printcmd.c:    error_no_arg (_("format-control string and values to print"));
printcmd.c:  /* Parse the format-control string and copy it into the string STRING,
printcmd.c:      error (_("Wrong number of arguments for specified format-string"));
proc-api.c:  { PIOCRFORK,     "PIOCRFORK",    "reset inherit-on-fork flag" },
proc-api.c:  { PIOCRRLC,      "PIOCRRLC",     "reset run-on-last-close flag" },
proc-api.c:  { PIOCSFORK,     "PIOCSFORK",    "set inherit-on-fork flag" },
proc-api.c:  { PIOCSRLC,      "PIOCSRLC",     "set run-on-last-close flag" },
proc-api.c:  { PIOCRTINH,     "PIOCRTINH",    "reset inherit-on-thread-creation" },
proc-api.c:  { PIOCSTINH,     "PIOCSTINH",    "set   inherit-on-thread-creation" },
proc-flags.c:  /* Sol2.5: inherit-on-fork is in effect
proc-flags.c:   * Sol2.6: inherit-on-fork is in effect
proc-flags.c:   * Sol2.7: inherit-on-fork is in effect
proc-flags.c:   * IRIX6:  process has inherit-on-fork flag set
proc-flags.c:   * OSF:    task/thread has inherit-on-fork flag set
proc-flags.c:   * UW:     inherit-on-fork is in effect
proc-flags.c:  { PR_FORK, "PR_FORK", "Inherit-on-fork is in effect" },
proc-flags.c:  /* Sol2.5: run-on-last-close is in effect
proc-flags.c:   * Sol2.6: run-on-last-close is in effect
proc-flags.c:   * Sol2.7: run-on-last-close is in effect
proc-flags.c:   * IRIX6:  process has run-on-last-close flag set
proc-flags.c:   * OSF:    task/thread has run-on-last-close flag set
proc-flags.c:   * UW:     Run-on-last-close is in effect
proc-flags.c:  { PR_RLC, "PR_RLC", "Run-on-last-close is in effect" },
proc-flags.c:  /* Sol2.5: kill-on-last-close is in effect
proc-flags.c:   * Sol2.6: kill-on-last-close is in effect
proc-flags.c:   * Sol2.7: kill-on-last-close is in effect
proc-flags.c:   * IRIX6:  process has kill-on-last-close flag set
proc-flags.c:   * OSF:    kill-on-last-close, superceeds RLC
proc-flags.c:   * UW:     kill-on-last-close is in effect
proc-flags.c:  { PR_KLC, "PR_KLC", "Kill-on-last-close is in effect" },
procfs.c:   *   different from those of a first-class process:
procfs.c:      pi->next = parent->thread_list;
procfs.c:      parent->thread_list = pi;
procfs.c:  ret->pr_size = (pi->num_syscalls + (8 * sizeof (uint64_t) - 1))
procfs.c:    if (mode == FLAG_SET)	/* Set run-on-last-close */
procfs.c:    else			/* Clear run-on-last-close */
procfs.c:    if (mode == FLAG_SET)	/* Set inherit-on-fork */
procfs.c:    else			/* Clear inherit-on-fork */
procfs.c:	destroy_one_procinfo (&parent->thread_list, thread);
procfs.c: * not to an LWP, because of the check for parent-process.
procfs.c:  /* FIXME: logically, we should really be turning OFF run-on-last-close,
procfs.c:     and possibly even turning ON kill-on-last-close at this point.  But
procfs.c:  /* Turn on run-on-last-close flag so that the child
procfs.c:  return pid_to_ptid (procinfo_list ? procinfo_list->pid : -1);
proc-service.c:  /* FIXME: We should really make supply_gregset const-correct.  */
proc-service.c:  /* FIXME: We should really make supply_fpregset const-correct.  */
prologue-value.c:     (e->next->offset < e->offset), because of the way < interacts
prologue-value.c:  while (((e->next->offset - offset) & area->addr_mask)
prologue-value.c:          e->next->prev = e->prev;
prologue-value.c:          e->prev->next = e->next->prev = e;
README:   GDB uses Expat, an XML parsing library, to implement some target-specific
README:Info formatting programs, such as `texinfo-format-buffer' or
README:one machine--the host--while debugging programs that run on another
regcache.c:     [0..NR_RAW_REGISTERS) is direct-mapped onto the corresponding raw
regcache.c:  struct gdbarch *gdbarch = dst->descr->gdbarch;
regcache.c:  gdb_assert (dst->readonly_p);
regcache.c:  memset (dst->registers, 0, dst->descr->sizeof_cooked_registers);
regcache.c:  memset (dst->register_valid_p, 0, dst->descr->sizeof_cooked_register_valid_p);
regcache.c:  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
regcache.c:	      dst->register_valid_p[regnum] = 1;
regcache.c:  struct gdbarch *gdbarch = dst->descr->gdbarch;
regcache.c:  gdb_assert (!dst->readonly_p);
regcache.c:  for (regnum = 0; regnum < dst->descr->nr_cooked_registers; regnum++)
regcache.c:  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
regcache.c:  gdb_assert (src->readonly_p || dst->readonly_p);
regcache.c:  else if (!dst->readonly_p)
regcache.c:  gdb_assert (src->descr->gdbarch == dst->descr->gdbarch);
regcache.c:  memcpy (dst->registers, src->registers, dst->descr->sizeof_raw_registers);
regcache.c:  memcpy (dst->register_valid_p, src->register_valid_p,
regcache.c:	  dst->descr->sizeof_raw_register_valid_p);
regcache.c:  /* See if we are trying to read bytes from out-of-date registers.  If so,
reggroups.c:    return groups->first->group;
reggroups.c:	    return el->next->group;
regset.c:  regset->arch = arch;
regset.c:  regset->supply_regset = supply_regset;
regset.c:  regset->collect_regset = collect_regset;
remote.c:#include "event-loop.h"
remote.c:#include "event-top.h"
remote.c:   writes and unaligned writes, but even as a best-effort attempt this
remote.c:     as the maximum packet-size to ensure that the packet and an extra
remote.c:  "memory-write-packet-size",
remote.c:  "memory-read-packet-size",
remote.c:      if (&packet->detect == c->var)
remote.c:      if (&packet->detect == c->var)
remote.c:  while ((count-- > 0) && (pkt < limit))
remote.c:      while (result_count--)
remote.c:  immediate_quit--;
remote.c:     "multi-part-packet" packet?  */
remote.c:     calls target_terminal_*() idenpotent. The event-loop GDB talking
remote.c:     function from both event-top.c and infrun.c/infcmd.c.  Once GDB
remote.c:   NOTE: This can still lose if the serial line is not eight-bit
remote.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote.c:      BREAKPOINT_FROM_PC (&bp_tgt->placed_address, &bp_tgt->placed_size);
remote.c:      addr = (ULONGEST) remote_address_masked (bp_tgt->placed_address);
remote.c:      sprintf (p, ",%d", bp_tgt->placed_size);
remote.c:  bp_tgt->placed_size = bp_tgt->shadow_len = sizeof big_break_insn;
remote.c:  val = target_read_memory (addr, bp_tgt->shadow_contents, bp_tgt->shadow_len);
remote.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote.c:      addr = (ULONGEST) remote_address_masked (bp_tgt->placed_address);
remote.c:      sprintf (p, ",%d", bp_tgt->placed_size);
remote.c:  return target_write_memory (bp_tgt->placed_address, bp_tgt->shadow_contents,
remote.c:			      bp_tgt->shadow_len);
remote.c:  BREAKPOINT_FROM_PC (&bp_tgt->placed_address, &bp_tgt->placed_size);
remote.c:  addr = remote_address_masked (bp_tgt->placed_address);
remote.c:  sprintf (p, ",%x", bp_tgt->placed_size);
remote.c:  addr = remote_address_masked (bp_tgt->placed_address);
remote.c:  sprintf (p, ",%x", bp_tgt->placed_size);
remote.c:  if (packet->support == PACKET_DISABLE)
remote.c:  for (; list != NULL; list = list->next)
remote.c:    if (strcmp (list->name, "Z-packet") == 0)
remote.c:    else if (list->type == not_set_cmd)
remote.c:	ui_out_field_string (uiout, "name", list->name);
remote.c:	if (list->type == show_cmd)
remote.c:  add_cmd ("memory-write-packet-size", no_class,
remote.c:  add_cmd ("memory-read-packet-size", no_class,
remote.c:  add_cmd ("memory-write-packet-size", no_class,
remote.c:  add_cmd ("memory-read-packet-size", no_class,
remote.c:  add_setshow_zinteger_cmd ("hardware-watchpoint-limit", no_class,
remote.c:  add_setshow_zinteger_cmd ("hardware-breakpoint-limit", no_class,
remote.c:			 "P", "set-register", 1);
remote.c:			 "qGetTLSAddr", "get-thread-local-storage-address",
remote-e7000.c:      /* FIXME!  this didn't seem right->  while (c != SERIAL_TIMEOUT)
remote-e7000.c:  immediate_quit--;
remote-e7000.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-e7000.c:	bp_tgt->shadow_len = 2;
remote-e7000.c:	e7000_read_inferior_memory (addr, bp_tgt->shadow_contents, 2);
remote-e7000.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-e7000.c:	e7000_write_inferior_memory (addr, bp_tgt->shadow_contents,
remote-e7000.c:				     bp_tgt->shadow_len);
remote-fileio.c:  remote_fileio_to_fio_uint ((long) st->st_ino, fst->fst_ino);
remote-fileio.c:  remote_fileio_to_fio_mode (st->st_mode, fst->fst_mode);
remote-fileio.c:  remote_fileio_to_fio_uint ((long) st->st_nlink, fst->fst_nlink);
remote-fileio.c:  remote_fileio_to_fio_uint ((long) st->st_uid, fst->fst_uid);
remote-fileio.c:  remote_fileio_to_fio_uint ((long) st->st_gid, fst->fst_gid);
remote-fileio.c:  remote_fileio_to_fio_uint ((long) st->st_rdev, fst->fst_rdev);
remote-fileio.c:  remote_fileio_to_fio_ulong ((LONGEST) st->st_size, fst->fst_size);
remote-fileio.c:  blksize = st->st_blksize;
remote-fileio.c:  remote_fileio_to_fio_ulong (blksize, fst->fst_blksize);
remote-fileio.c:  remote_fileio_to_fio_ulong ((LONGEST) st->st_blocks, fst->fst_blocks);
remote-fileio.c:  remote_fileio_to_fio_ulong (((LONGEST) st->st_size + blksize - 1)
remote-fileio.c:			      fst->fst_blocks);
remote-fileio.c:  remote_fileio_to_fio_time (st->st_atime, fst->fst_atime);
remote-fileio.c:  remote_fileio_to_fio_time (st->st_mtime, fst->fst_mtime);
remote-fileio.c:  remote_fileio_to_fio_time (st->st_ctime, fst->fst_ctime);
remote-m32r-sdi.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-m32r-sdi.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-mips.c:	      immediate_quit--;
remote-mips.c:/* Insert a breakpoint.  On targets that don't have built-in
remote-mips.c:    return set_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
remote-mips.c:    return clear_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
remote-mips.c: * byte count-+     address
remote-mips.c:/* The PMON fast-download uses an encoded packet format constructed of
remote-mips.c:	    /* Ensure no out-standing zerofill requests: */
remote-mips.c:  /* Initialize target-specific fields in the target vectors.  */
remote-mips.c:  add_setshow_zinteger_cmd ("retransmit-timeout", no_class,
remote-sds.c:  immediate_quit--;
remote-sds.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-sds.c:    bp_tgt->shadow_contents[i] = buf[i + 2];
remote-sds.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-sds.c:    *p++ = bp_tgt->shadow_contents[i];
remote-st.c:	      immediate_quit--;
remote-st.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-st.c:  CORE_ADDR addr = bp_tgt->placed_address;
remote-utils.c:	      immediate_quit--;
rs6000-nat.c:/* Store in *TO the 32-bit word at 32-bit-aligned ADDR in the child
rs6000-nat.c:	if (DEPRECATED_STREQ (mem, last->filename))
rs6000-nat.c:	  stp = target->to_sections_end - 2;
rs6000-tdep.c:/* Target-dependent code for GDB, the GNU debugger.
rs6000-tdep.c:  const struct ppc_reg_offsets *offsets = regset->descr;
rs6000-tdep.c:  const struct ppc_reg_offsets *offsets = regset->descr;
rs6000-tdep.c:  const struct ppc_reg_offsets *offsets = regset->descr;
rs6000-tdep.c:  const struct ppc_reg_offsets *offsets = regset->descr;
rs6000-tdep.c:     that it still has control over this not-yet-allocated stack
s390-nat.c:  t->to_fetch_registers = s390_linux_fetch_inferior_registers;
s390-nat.c:  t->to_store_registers = s390_linux_store_inferior_registers;
s390-nat.c:  t->to_can_use_hw_breakpoint = s390_can_use_hw_breakpoint;
s390-nat.c:  t->to_region_ok_for_hw_watchpoint = s390_region_ok_for_hw_watchpoint;
s390-nat.c:  t->to_have_continuable_watchpoint = 1;
s390-nat.c:  t->to_stopped_by_watchpoint = s390_stopped_by_watchpoint;
s390-nat.c:  t->to_insert_watchpoint = s390_insert_watchpoint;
s390-nat.c:  t->to_remove_watchpoint = s390_remove_watchpoint;
s390-tdep.c:/* Target-dependent code for GDB, the GNU debugger.
s390-tdep.c:  const int *offset = regset->descr;
s390-tdep.c:  const int *offset = regset->descr;
s390-tdep.c:     by a branch 'br %r14' --or equivalent-- that effects the
s390-tdep.c:/* Return non-zero if TYPE is a struct-like type, zero otherwise.
s390-tdep.c:   "Struct-like" types are those that should be passed as structs are:
s390-tdep.c:/* Return non-zero if TYPE is a float-like type, zero otherwise.
s390-tdep.c:   "Float-like" types are those that should be passed as
s390-tdep.c:   prototypes or the old K&R argument-passing rules.  */
s390-tdep.c:  /* After all that, make sure it's still aligned on an eight-byte
s390-tdep.c:     always be aligned on an eight-byte boundary.  */
s390-tdep.h:/* Target-dependent code for GDB, the GNU debugger.
scm-valprint.c:  "call-with-current-continuation",
ser-base.c:#include "event-loop.h"
ser-base.c:   the need to make redundant calls into the event-loop - the next
ser-base.c:  scb->bufcnt--;
ser-base.c:      scb->bufcnt--;
ser-base.c:/* Put the SERIAL device into/out-of ASYNC mode.  */
ser-go32.c:  if (port->count == 0)
ser-go32.c:  c = port->cbuf[port->first];
ser-go32.c:  port->first = (port->first + 1) & (CBSIZE - 1);
ser-go32.c:  port->count--;
ser-go32.c:  if (port->count >= CBSIZE - 1)
ser-go32.c:  port->cbuf[(port->first + port->count) & (CBSIZE - 1)] = c;
ser-go32.c:  port->count++;
ser-go32.c:		    port->ferr++;
ser-go32.c:		    port->perr++;
ser-go32.c:		    port->oflo++;
ser-go32.c:	  port->msr = inb (port, com_msr);
ser-go32.c:	  port->txbusy = 0;
ser-go32.c:  if (port->refcnt++ > 0)
ser-go32.c:  port->fifo = ((inb (port, com_iir) & IIR_FIFO_MASK) == IIR_FIFO_MASK);
ser-go32.c:  port->intrupt = dos_hookirq (port->irq);
ser-go32.c:  if (!port->intrupt)
ser-go32.c:  port->intrupt->port = port;
ser-go32.c:  port->first = port->count = 0;
ser-go32.c:  port->txbusy = 0;
ser-go32.c:  port->oflo = 0;
ser-go32.c:  i = dos_baudconv (port->baudrate = 9600);
ser-go32.c:  if (port->refcnt-- > 1)
ser-go32.c:  if (!(intrupt = port->intrupt))
ser-go32.c:  port->intrupt = 0;
ser-go32.c:  intrupt->port = 0;
ser-go32.c:  if (port->oflo)
ser-go32.c:			  port->fifo ? "cannot" : "needs a 16550 to",
ser-go32.c:			  port->baudrate);
ser-go32.c:  if (port->refcnt <= 0)
ser-go32.c:  port->first = port->count = 0;
ser-go32.c:  if (port->fifo)
ser-go32.c:  if (port->baudrate != rate)
ser-go32.c:      port->baudrate = rate;
ser-go32.c:  int fifosize = port->fifo ? 16 : 1;
ser-go32.c:      port->txbusy = 1;
ser-go32.c:      outportsb (port->base + com_data, str, cnt);
ser-go32.c:      for ( ; cnt > 0; cnt--, len--)
ser-go32.c:	outportb (port->base + com_data, *str++);
ser-go32.c:      while (port->txbusy)
ser-go32.c:      if (port->baudrate == 0)
ser-go32.c:		       port->intrupt ? "" : "not ");
ser-go32.c:      printf_filtered ("Addr:\t0x%03x (irq %d)\n", port->base, port->irq);
ser-go32.c:      printf_filtered ("16550:\t%s\n", port->fifo ? "yes" : "no");
ser-go32.c:      printf_filtered ("Speed:\t%d baud\n", port->baudrate);
ser-go32.c:		       port->ferr, port->perr, port->oflo);
serial.c:  scb->refcnt--;
serial.c:	tmp_scb->next = tmp_scb->next->next;
serial.h:  SERIAL_TIMEOUT = -2,	/* Timeout or data-not-ready during read.
ser-tcp.c:  memcpy (&sockaddr.sin_addr.s_addr, hostent->h_addr,
ser-unix.c:      scb->bufcnt--;
sh64-tdep.c:/* Target-dependent code for Renesas Super-H, for GDB.
sh64-tdep.c:   right-justified in the register or the stack word.  This includes
sh64-tdep.c:   bug.  Arguments of these odd sizes are left-justified within the 
sh64-tdep.c:   right-justified).
sh64-tdep.c:	      /* value gets right-justified in the register or stack word */
sh64-tdep.c:   the result is stored in r0, left-justified.  */
sh-linux-tdep.c:/* Target-dependent code for GNU/Linux Super-H.
shnbsd-tdep.c:/* Target-dependent code for SuperH running NetBSD, for GDB.
shnbsd-tdep.h:/* Target-dependent definitions for SuperH running NetBSD, for GDB.
sh-tdep.c:/* Target-dependent code for Renesas Super-H, for GDB.
sh-tdep.c:   right-justified in the register or the stack word.  This includes
sh-tdep.c:   bug.  Arguments of these odd sizes are left-justified within the 
sh-tdep.c:   right-justified).
sh-tdep.c:      /* value gets right-justified in the register or stack word */
sh-tdep.c:   the result is stored in r0, left-justified. */
sh-tdep.h:/* Target-specific definition for a Renesas Super-H.
sol2-tdep.c:/* Target-dependent code for Solaris.
sol2-tdep.h:/* Target-dependent code for Solaris.
solib-aix5.c:	  next = next->next;
solib-aix5.c:	  int flags = bfd_get_section_flags (obfd, sect->the_bfd_section);
solib-aix5.c:	      file_ptr filepos = sect->the_bfd_section->filepos;
solib-aix5.c:		    bfd_get_section_name (obfd, sect->the_bfd_section)))
solib-aix5.c:		  int idx = sect->the_bfd_section->index;
solib-aix5.c:		      - (bfd_section_vma (obfd, sect->the_bfd_section) 
solib.c:		  memcpy (target->to_sections + space,
solib-frv.c:      osect_idx = osect->the_bfd_section->index;
solib-frv.c:      addr = osect->addr;
solib-osf.c:     the value for ctxt->proc.  This is incorrect, however, since
solib-osf.c:  ctxt->proc = ptid_get_pid (inferior_ptid);
solib-osf.c:  if (ldr_xattach (ctxt->proc) != 0)
solib-osf.c:  ctxt->next = LDR_NULL_MODULE;
solib-osf.c:  ctxt->next = ldr_context.head;
solib-osf.c:  ctxt->tail = ldr_context.tail;
solib-osf.c:  if (ldr_next_module (ctxt->proc, &ctxt->next) != 0)
solib-osf.c:  if (ctxt->next == LDR_NULL_MODULE)
solib-osf.c:  if (ldr_inq_module (ctxt->proc, ctxt->next, &minf, sizeof minf, &size) != 0)
solib-osf.c:      if (ldr_inq_region (ctxt->proc, ctxt->next, i, &rinf,
solib-osf.c:  if (!ctxt->next)
solib-osf.c:  if (target_read_memory (ctxt->next, (char *) &minf, sizeof minf) != 0)
solib-osf.c:  if (ctxt->next == ctxt->tail)
solib-osf.c:    ctxt->next = 0;
solib-osf.c:    ctxt->next = minf.next;
solib-osf.c:  ldr_xdetach (ctxt->proc);
solib-pa64.c:      if (so_list->lm_info->desc.text_base <= addr
solib-pa64.c:	  && ((so_list->lm_info->desc.text_base
solib-pa64.c:	       + so_list->lm_info->desc.text_size)
solib-pa64.c:	  got_value = so_list->lm_info->desc.linkage_ptr;
solib-pa64.c:      so_list = so_list->next;
solib-pa64.c:      if (so_list->lm_info->desc.text_base <= addr
solib-pa64.c:	  && ((so_list->lm_info->desc.text_base
solib-pa64.c:	       + so_list->lm_info->desc.text_size)
solib-pa64.c:	  retval = so_list->lm_info->desc_addr;
solib-pa64.c:      so_list = so_list->next;
solib-som.c:      if (so_list->lm_info->text_addr <= addr
solib-som.c:	  && so_list->lm_info->text_end > addr)
solib-som.c:	  got_value = so_list->lm_info->got_value;
solib-som.c:      so_list = so_list->next;
solib-som.c:      if (so_list->lm_info->text_addr <= addr
solib-som.c:	  && so_list->lm_info->text_end > addr)
solib-som.c:      so_list = so_list->next;
solib-som.c:    return so_list->lm_info->lm_addr;
solib-som.c:      /* Oh what a pain!  We need the offsets before so_list->objfile
solib-som.c:      if (strstr (objfile->name, so_list->so_name))
solib-som.c:	    = (so_list->lm_info->text_addr
solib-som.c:	       - so_list->lm_info->text_link_addr);
solib-som.c:	    = (so_list->lm_info->data_start - private_section->vma);
solib-som.c:      so_list = so_list->next;
solib-svr4.c:/* Clear any bits of ADDR that wouldn't fit in a target-format
sol-thread.c:/* Mark our target-struct as eligible for stray "run" and "attach"
source.c:      if (cs_pst->readin)
source.c:	if (pst->fullname != NULL)
source.c:	    xfree (pst->fullname);
source.c:	    pst->fullname = NULL;
sparc64fbsd-nat.c:  t->to_pid_to_exec_file = fbsd_pid_to_exec_file;
sparc64fbsd-nat.c:  t->to_find_memory_regions = fbsd_find_memory_regions;
sparc64fbsd-nat.c:  t->to_make_corefile_notes = fbsd_make_corefile_notes;
sparc64fbsd-tdep.c:/* Target-dependent code for FreeBSD/sparc64.
sparc64-linux-nat.c:  t->to_fetch_registers = fetch_inferior_registers;
sparc64-linux-nat.c:  t->to_store_registers = store_inferior_registers;
sparc64-linux-tdep.c:/* Target-dependent code for GNU/Linux UltraSPARC.
sparc64nbsd-tdep.c:/* Target-dependent code for NetBSD/sparc64.
sparc64obsd-tdep.c:/* Target-dependent code for OpenBSD/sparc64.
sparc64-sol2-tdep.c:/* Target-dependent code for Solaris UltraSPARC.
sparc64-tdep.c:/* Target-dependent code for UltraSPARC.
sparc64-tdep.c:                 parameter array, and right-justified within that
sparc64-tdep.c:	  int offset = gregset->r_tstate_offset;
sparc64-tdep.c:			     regs + gregset->r_pc_offset + 4);
sparc64-tdep.c:			     regs + gregset->r_npc_offset + 4);
sparc64-tdep.c:	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
sparc64-tdep.c:			     regs + gregset->r_tstate_offset);
sparc64-tdep.c:			     regs + gregset->r_pc_offset);
sparc64-tdep.c:			     regs + gregset->r_npc_offset);
sparc64-tdep.c:	  memcpy (buf + 8 - gregset->r_y_size,
sparc64-tdep.c:		  regs + gregset->r_y_offset, gregset->r_y_size);
sparc64-tdep.c:	  && gregset->r_fprs_offset != -1)
sparc64-tdep.c:			     regs + gregset->r_fprs_offset);
sparc64-tdep.c:      int offset = gregset->r_g1_offset;
sparc64-tdep.c:      if (gregset->r_l0_offset == -1)
sparc64-tdep.c:	  int offset = gregset->r_l0_offset;
sparc64-tdep.c:	  int offset = gregset->r_tstate_offset;
sparc64-tdep.c:			      regs + gregset->r_pc_offset + 4);
sparc64-tdep.c:			      regs + gregset->r_npc_offset + 4);
sparc64-tdep.c:	  int offset = gregset->r_y_offset + 8 - gregset->r_y_size;
sparc64-tdep.c:			      regs + gregset->r_tstate_offset);
sparc64-tdep.c:			      regs + gregset->r_pc_offset);
sparc64-tdep.c:			      regs + gregset->r_npc_offset);
sparc64-tdep.c:	  memcpy (regs + gregset->r_y_offset,
sparc64-tdep.c:		  buf + 8 - gregset->r_y_size, gregset->r_y_size);
sparc64-tdep.c:	  && gregset->r_fprs_offset != -1)
sparc64-tdep.c:			      regs + gregset->r_fprs_offset);
sparc64-tdep.c:      int offset = gregset->r_g1_offset;
sparc64-tdep.c:      if (gregset->r_l0_offset != -1)
sparc64-tdep.c:	  int offset = gregset->r_l0_offset;
sparc64-tdep.h:/* Target-dependent code for UltraSPARC.
sparc-linux-nat.c:  t->to_fetch_registers = fetch_inferior_registers;
sparc-linux-nat.c:  t->to_store_registers = store_inferior_registers;
sparc-linux-tdep.c:/* Target-dependent code for GNU/Linux SPARC.
sparc-nat.c:  t->to_fetch_registers = fetch_inferior_registers;
sparc-nat.c:  t->to_store_registers = store_inferior_registers;
sparc-nat.c:  inf_ptrace_xfer_partial = t->to_xfer_partial;
sparc-nat.c:  t->to_xfer_partial = sparc_xfer_partial;
sparcnbsd-tdep.c:/* Target-dependent code for NetBSD/sparc.
sparcnbsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-sparc-netbsd") == 0)
sparcobsd-tdep.c:/* Target-dependent code for OpenBSD/sparc.
sparc-sol2-tdep.c:/* Target-dependent code for Solaris SPARC.
sparc-stub.c:  while (count-- > 0)
sparc-stub.c:  for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
sparc-stub.c:    exceptionHandler(ht->tt, trap_low);
sparc-stub.c:  for (ht = hard_trap_info; ht->tt && ht->signo; ht++)
sparc-stub.c:    if (ht->tt == tt)
sparc-stub.c:      return ht->signo;
sparc-tdep.c:/* Target-dependent code for SPARC.
sparc-tdep.c:         an "unimp" instruction.  If it is, then it is a struct-return
sparc-tdep.c:			 regs + gregset->r_psr_offset);
sparc-tdep.c:			 regs + gregset->r_pc_offset);
sparc-tdep.c:			 regs + gregset->r_npc_offset);
sparc-tdep.c:			 regs + gregset->r_y_offset);
sparc-tdep.c:      int offset = gregset->r_g1_offset;
sparc-tdep.c:      if (gregset->r_l0_offset == -1)
sparc-tdep.c:	  int offset = gregset->r_l0_offset;
sparc-tdep.c:			  regs + gregset->r_psr_offset);
sparc-tdep.c:			  regs + gregset->r_pc_offset);
sparc-tdep.c:			  regs + gregset->r_npc_offset);
sparc-tdep.c:			  regs + gregset->r_y_offset);
sparc-tdep.c:      int offset = gregset->r_g1_offset;
sparc-tdep.c:      if (gregset->r_l0_offset != -1)
sparc-tdep.c:	  int offset = gregset->r_l0_offset;
sparc-tdep.h:/* Target-dependent code for SPARC.
spu-linux-nat.c:  xsnprintf (annex, sizeof annex, "%d/object-id", inferior_fd);
spu-linux-nat.c:  t->to_post_attach = spu_child_post_attach;  
spu-linux-nat.c:  t->to_post_startup_inferior = spu_child_post_startup_inferior;
spu-linux-nat.c:  t->to_wait = spu_child_wait;
spu-linux-nat.c:  t->to_fetch_registers = spu_fetch_inferior_registers;
spu-linux-nat.c:  t->to_store_registers = spu_store_inferior_registers;
spu-linux-nat.c:  t->to_xfer_partial = spu_xfer_partial;
spu-linux-nat.c:  t->to_can_use_hw_breakpoint = spu_can_use_hw_breakpoint;
spu-tdep.c:/* SPU target-dependent code for GDB, the GNU debugger.
spu-tdep.c:     STRUCT_ADDR) will consume the first argument-passing register.
spu-tdep.h:/* SPU target-dependent code for GDB, the GNU debugger.
stabsread.c:	    /* FIXME-if-picky-about-floating-accuracy: Should be using
stabsread.c:   definition, the distinction is relevant--some parts of stabsread.c
stabsread.c:	for (ppt = file_symbols; ppt; ppt = ppt->next)
stabsread.c:	  for (i = 0; i < ppt->nsyms; i++)
stabsread.c:	      struct symbol *sym = ppt->symbol[i];
stabsread.c:    case '-':			/* RS/6000 built-in type */
stabsread.c:             fields array right-to-left.  */
stabsread.c:          for (t = arg_types, i = num_args - 1; t; t = t->next, i--)
stabsread.c:            TYPE_FIELD_TYPE (func_type, i) = t->type;
stabsread.c:      new_fnlist->fn_fieldlist.name = main_fn_name;
stabsread.c:	      new_sublist->fn_field.type = read_type (pp, objfile);
stabsread.c:	      new_sublist->fn_field.type = look_ahead_type;
stabsread.c:	  if (TYPE_STUB (new_sublist->fn_field.type))
stabsread.c:	      if (!TYPE_DOMAIN_TYPE (new_sublist->fn_field.type))
stabsread.c:		TYPE_DOMAIN_TYPE (new_sublist->fn_field.type) = type;
stabsread.c:	      new_sublist->fn_field.is_stub = 1;
stabsread.c:	  new_sublist->fn_field.physname = savestring (*pp, p - *pp);
stabsread.c:	      new_sublist->fn_field.is_private = 1;
stabsread.c:	      new_sublist->fn_field.is_protected = 1;
stabsread.c:	      new_sublist->fn_field.is_const = 0;
stabsread.c:	      new_sublist->fn_field.is_volatile = 0;
stabsread.c:	      new_sublist->fn_field.is_const = 1;
stabsread.c:	      new_sublist->fn_field.is_volatile = 0;
stabsread.c:	      new_sublist->fn_field.is_const = 0;
stabsread.c:	      new_sublist->fn_field.is_volatile = 1;
stabsread.c:	      new_sublist->fn_field.is_const = 1;
stabsread.c:	      new_sublist->fn_field.is_volatile = 1;
stabsread.c:		new_sublist->fn_field.voffset =
stabsread.c:		    new_sublist->fn_field.fcontext = 0;
stabsread.c:			new_sublist->fn_field.fcontext = look_ahead_type;
stabsread.c:		new_sublist->fn_field.voffset = VOFFSET_STATIC;
stabsread.c:		if (!(strncmp (new_sublist->fn_field.physname,
stabsread.c:		      && new_sublist->fn_field.physname[slen] == '_'
stabsread.c:		      && new_sublist->fn_field.physname[slen + 1] == '_'))
stabsread.c:		    new_sublist->fn_field.is_stub = 1;
stabsread.c:	      new_sublist->fn_field.voffset = 0;
stabsread.c:	      new_sublist->fn_field.fcontext = 0;
stabsread.c:	  new_sublist->next = sublist;
stabsread.c:	      if (tmp_sublist->fn_field.is_stub)
stabsread.c:	      if (tmp_sublist->fn_field.physname[0] == '_'
stabsread.c:		  && tmp_sublist->fn_field.physname[1] == 'Z')
stabsread.c:	      if (is_destructor_name (tmp_sublist->fn_field.physname))
stabsread.c:	      tmp_sublist = tmp_sublist->next;
stabsread.c:	      destr_fnlist->fn_fieldlist.name
stabsread.c:			    new_fnlist->fn_fieldlist.name);
stabsread.c:	      destr_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
stabsread.c:	      memset (destr_fnlist->fn_fieldlist.fn_fields, 0,
stabsread.c:		  if (!is_destructor_name (tmp_sublist->fn_field.physname))
stabsread.c:		      tmp_sublist = tmp_sublist->next;
stabsread.c:		  destr_fnlist->fn_fieldlist.fn_fields[i++]
stabsread.c:		    = tmp_sublist->fn_field;
stabsread.c:		    last_sublist->next = tmp_sublist->next;
stabsread.c:		    sublist = tmp_sublist->next;
stabsread.c:		  tmp_sublist = tmp_sublist->next;
stabsread.c:	      destr_fnlist->fn_fieldlist.length = has_destructor;
stabsread.c:	      destr_fnlist->next = fip->fnlist;
stabsread.c:	      update_method_name_from_physname (&new_fnlist->fn_fieldlist.name,
stabsread.c:						sublist->fn_field.physname);
stabsread.c:	  else if (has_destructor && new_fnlist->fn_fieldlist.name[0] != '~')
stabsread.c:	      new_fnlist->fn_fieldlist.name =
stabsread.c:	      ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
stabsread.c:		ret = cplus_demangle_opname (new_fnlist->fn_fieldlist.name,
stabsread.c:		new_fnlist->fn_fieldlist.name
stabsread.c:	  new_fnlist->fn_fieldlist.fn_fields = (struct fn_field *)
stabsread.c:	  memset (new_fnlist->fn_fieldlist.fn_fields, 0,
stabsread.c:	  for (i = length; (i--, sublist); sublist = sublist->next)
stabsread.c:	      new_fnlist->fn_fieldlist.fn_fields[i] = sublist->fn_field;
stabsread.c:	  new_fnlist->fn_fieldlist.length = length;
stabsread.c:	  new_fnlist->next = fip->fnlist;
stabsread.c:	  fip->list->field.name =
stabsread.c:	  fip->list->field.name =
stabsread.c:	  fip->list->field.name =
stabsread.c:      fip->list->field.type = read_type (pp, objfile);
stabsread.c:	FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ';', &nbits,
stabsread.c:      FIELD_BITSIZE (fip->list->field) = 0;
stabsread.c:      fip->list->visibility = VISIBILITY_PRIVATE;
stabsread.c:  fip->list->field.name =
stabsread.c:      fip->list->visibility = *(*pp)++;
stabsread.c:      fip->list->visibility = VISIBILITY_PUBLIC;
stabsread.c:  fip->list->field.type = read_type (pp, objfile);
stabsread.c:	  fip->list->field.bitpos = (long) -2;	/* nested type */
stabsread.c:      SET_FIELD_PHYSNAME (fip->list->field, savestring (*pp, p - *pp));
stabsread.c:    FIELD_BITPOS (fip->list->field) = read_huge_number (pp, ',', &nbits, 0);
stabsread.c:    FIELD_BITSIZE (fip->list->field) = read_huge_number (pp, ';', &nbits, 0);
stabsread.c:  if (FIELD_BITPOS (fip->list->field) == 0
stabsread.c:      && FIELD_BITSIZE (fip->list->field) == 0)
stabsread.c:      fip->list->visibility = VISIBILITY_IGNORE;
stabsread.c:      struct type *field_type = check_typedef (FIELD_TYPE (fip->list->field));
stabsread.c:	  FIELD_BITSIZE (fip->list->field) = 0;
stabsread.c:      if ((FIELD_BITSIZE (fip->list->field)
stabsread.c:	       && FIELD_BITSIZE (fip->list->field) == TARGET_INT_BIT)
stabsread.c:	  FIELD_BITPOS (fip->list->field) % 8 == 0)
stabsread.c:	  FIELD_BITSIZE (fip->list->field) = 0;
stabsread.c:      fip->list = fip->list->next;
stabsread.c:       fip->fnlist = fip->fnlist->next)
stabsread.c:      TYPE_FN_FIELDLISTS (type)[n] = fip->fnlist->fn_fieldlist;
stabsread.c:      TYPE_FIELD (type, nfields) = fip->list->field;
stabsread.c:      switch (fip->list->visibility)
stabsread.c:		       fip->list->visibility);
stabsread.c:      fip->list = fip->list->next;
stabsread.c:       next = next->next)
stabsread.c:      for (j = 0; j < next->nsyms; j++)
stabsread.c:	add_symbol_to_list (next->symbol[j], &new);
stabsread.c:  for (; next; next = next->next)
stabsread.c:      for (j = next->nsyms - 1; j >= 0; j--)
stabsread.c:	SYMBOL_VALUE_ADDRESS (next->symbol[j]) += valu;
stabsread.c:		for (ppt = file_symbols; ppt; ppt = ppt->next)
stabsread.c:		    for (i = 0; i < ppt->nsyms; i++)
stabsread.c:			struct symbol *sym = ppt->symbol[i];
stabsread.h:   using --split-by-reloc.  This linked list is used to pass the
stack.c:	  while (current && count--)
stack.c:  for (i = 0, fi = trailing; fi && count--; i++, fi = get_prev_frame (fi))
stack.c:  /* Store RETURN_VALUE in the just-returned register set.  */
stack.c:  add_com ("select-frame", class_stack, select_frame_command, _("\
std-regs.c:       register name table overrides this built-in $fp register, there
symfile.c:  qsort (pst->objfile->global_psymbols.list + pst->globals_offset,
symfile.c:	 pst->n_global_syms, sizeof (struct partial_symbol *),
symfile.c:  if (pst->symtab)
symfile.c:    return pst->symtab;
symfile.c:  if (!pst->readin)
symfile.c:      (*pst->read_symtab) (pst);
symfile.c:  return pst->symtab;
symfile.c:/* Remember the lowest-addressed loadable section we've seen.
symfile.c:   lowest-addressed loadable section.
symfile.c:   lowest-addressed loadable section.  */
symfile.c:    objfile->sect_index_text = sect->index;
symfile.c:    objfile->sect_index_data = sect->index;
symfile.c:    objfile->sect_index_bss = sect->index;
symfile.c:    objfile->sect_index_rodata = sect->index;
symfile.c:  if (offsets[sect->index] != 0)
symfile.c:  offsets[sect->index] = start_addr;
symfile.c:  exec_set_section_address (bfd_get_filename (abfd), sect->index, start_addr);
symfile.c:   into a format-specific offset table --- a `struct section_offsets'.
symfile.c:   format-specific representation.  NUM_OFFSETS is the number of
symfile.c:                    addrs->other[i].sectindex = sect->index ;
symfile.c:      if (pst->filename != NULL)
symfile.c:	lang = deduce_language_from_filename (pst->filename);
symfile.c:    return sect->index;
symfile.c:  new_request->begin = bfd_section_lma (abfd, asec) + args->load_offset;
symfile.c:  new_request->end = new_request->begin + size; /* FIXME Should size be in instead?  */
symfile.c:  new_request->data = xmalloc (size);
symfile.c:  new_request->baton = section_data;
symfile.c:  buffer = new_request->data;
symfile.c:  section_data->lma = new_request->begin;
symfile.c:    printf_filtered ("\t%s\t- %s\n",
symfile.c:  prev_pst = &(pst->objfile->psymtabs);
symfile.c:  (*prev_pst) = pst->next;
symfile.c:  pst->next = pst->objfile->free_psymtabs;
symfile.c:  pst->objfile->free_psymtabs = pst;
symfile.c:  for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
symfile.c:      if (ps == pst->objfile->psymtabs)
symfile.c:	pst->objfile->psymtabs = ps->next;
symfile.c:      for (ps = pst->objfile->psymtabs; ps; ps = ps->next)
symfile.c:  if (list->next >= list->list + list->size)
symfile.c:  *list->next++ = psym;
symfile.c:  if (list->next >= list->list + list->size)
symfile.c:  *list->next++ = psym;
symfile.c:   the target-specific code provides functionality to read the target's
symfile.c:    if (section_is_overlay (sect->the_bfd_section))
symfile.c:    sect->ovly_mapped = -1;
symfile.c:  if (osect == 0 || !section_is_overlay (osect->the_bfd_section))
symfile.c:	  if (osect->ovly_mapped == -1)
symfile.c:      return osect->ovly_mapped == 1;
symfile.c:	if (osect->the_bfd_section == section)
symfile.c:   Return the best-match overlay section for PC:
symfile.c:      if (section_is_overlay (osect->the_bfd_section))
symfile.c:	if (pc_in_mapped_range (pc, osect->the_bfd_section))
symfile.c:	      return osect->the_bfd_section;
symfile.c:	else if (pc_in_unmapped_range (pc, osect->the_bfd_section))
symfile.c:      if (pc_in_mapped_range (pc, osect->the_bfd_section) &&
symfile.c:      return osect->the_bfd_section;
symfile.c:	vma = bfd_section_vma (objfile->obfd, osect->the_bfd_section);
symfile.c:	lma = bfd_section_lma (objfile->obfd, osect->the_bfd_section);
symfile.c:	size = bfd_get_section_size (osect->the_bfd_section);
symfile.c:	name = bfd_section_name (objfile->obfd, osect->the_bfd_section);
symfile.c:  bfd *obfd = osect->objfile->obfd;
symfile.c:  asection *bsect = osect->the_bfd_section;
symfile.c:  size = bfd_get_section_size (osect->the_bfd_section);
symfile.c:	    osect->ovly_mapped = cache_ovly_table[i][MAPPED];
symfile.c:    if (section_is_overlay (osect->the_bfd_section))
symfile.c:      bfd *obfd = osect->objfile->obfd;
symfile.c:      asection *bsect = osect->the_bfd_section;
symfile.c:	    osect->ovly_mapped = cache_ovly_table[i][MAPPED];
symfile.c:  add_cmd ("list-overlays", class_support, list_overlays_command,
symfile-mem.c:   hope BFD will provide a format-independent bfd_from_remote_memory
symmisc.c:  immediate_quit--;
symmisc.c:  immediate_quit--;
symmisc.c:  immediate_quit--;
symmisc.c:      error (_("print-psymbols takes an output file name and optional symbol file name"));
symmisc.c:  immediate_quit--;
symmisc.c:  while (count-- > 0)
symmisc.c:      error (_("print-msymbols takes an output file name and optional symbol file name"));
symmisc.c:  immediate_quit--;
symmisc.c:  immediate_quit--;
symtab.c:    if (FILENAME_CMP (name, pst->filename) == 0)
symtab.c:	if (pst->fullname != NULL
symtab.c:	    && FILENAME_CMP (full_path, pst->fullname) == 0)
symtab.c:        if (pst->fullname != NULL)
symtab.c:            rp = gdb_realpath (pst->fullname);
symtab.c:      if (FILENAME_CMP (lbasename (pst->filename), name) == 0)
symtab.c:  if (first->owner == NULL || second->owner == NULL)
symtab.c:  if (first->owner == second->owner)
symtab.c:  if (bfd_get_section_vma (first->owner, first)
symtab.c:  if (bfd_get_section_name (first->owner, first) == NULL
symtab.c:      || strcmp (bfd_get_section_name (first->owner, first),
symtab.c:    if (obj->obfd == first->owner)
symtab.c:    if (pc >= pst->textlow && pc < pst->texthigh)
symtab.c:	for (tpst = pst; tpst != NULL; tpst = tpst->next)
symtab.c:	    if (pc >= tpst->textlow && pc < tpst->texthigh)
symtab.c:  int length = (global ? pst->n_global_syms : pst->n_static_syms);
symtab.c:	   pst->objfile->global_psymbols.list + pst->globals_offset :
symtab.c:	   pst->objfile->static_psymbols.list + pst->statics_offset);
symtab.c:      if (item->pc > pc && (!alt || item->pc < alt->pc))
symtab.c:      if (prev && prev->line && (!best || prev->pc > best->pc))
symtab.c:	  if (best_end <= best->pc)
symtab.c:      if (best && i < len && item->pc > best->pc
symtab.c:	  val.line = alt->line - 1;
symtab.c:	  val.end = alt->pc;
symtab.c:  else if (best->line == 0)
symtab.c:      val.line = best->line;
symtab.c:      val.pc = best->pc;
symtab.c:      if (best_end && (!alt || best_end < alt->pc))
symtab.c:	val.end = alt->pc;
symtab.c:  /* variable, func, or typedef-that-is-c++-class */
symtab.c:  /* Initialize the one built-in type that isn't language dependent... */
symtab.h:     way until target-dependent code sets it.  Storage for any data
symtab.h:     target-specific method. This is used only by hppa.  */
symtab.h:     format-dependent symbol reading routines.  For further detail examine
symtab.h:#define CURRENT_EXCEPTION_KIND       (current_exception_event->kind)
symtab.h:#define CURRENT_EXCEPTION_CATCH_SAL  (current_exception_event->catch_sal)
symtab.h:#define CURRENT_EXCEPTION_CATCH_LINE (current_exception_event->catch_sal.line)
symtab.h:#define CURRENT_EXCEPTION_CATCH_FILE (current_exception_event->catch_sal.symtab->filename)
symtab.h:#define CURRENT_EXCEPTION_CATCH_PC   (current_exception_event->catch_sal.pc)
symtab.h:#define CURRENT_EXCEPTION_THROW_SAL  (current_exception_event->throw_sal)
symtab.h:#define CURRENT_EXCEPTION_THROW_LINE (current_exception_event->throw_sal.line)
symtab.h:#define CURRENT_EXCEPTION_THROW_FILE (current_exception_event->throw_sal.symtab->filename)
symtab.h:#define CURRENT_EXCEPTION_THROW_PC   (current_exception_event->throw_sal.pc)
target.c:  if (t->to_xfer_partial == NULL)
target.c:    t->to_xfer_partial = default_xfer_partial;
target.c:  add_cmd (t->to_shortname, no_class, t->to_open, t->to_doc, &targetlist);
target.c:  for (t = target_stack; t; t = t->beneath)
target.c:  /* Finally, position the target-stack beneath the squashed
target.c:  for (t = target_stack; t != NULL; t = t->beneath)
target.c:  for (t = target_stack; t != NULL; t = t->beneath)
target.c:  if (t->to_magic != OPS_MAGIC)
target.c:			  t->to_shortname);
target.c:      if ((int) (t->to_stratum) >= (int) (*cur)->to_stratum)
target.c:  while ((*cur) != NULL && t->to_stratum == (*cur)->to_stratum)
target.c:  t->beneath = (*cur);
target.c:  for (secp = target->to_sections;
target.c:       secp < target->to_sections_end;
target.c:  /* Try the executable file, if "trust-readonly-sections" is set.  */
target.c:  for (t = current_target.beneath; t != NULL; t = t->beneath)
target.c:    if (t->to_memory_map != NULL)
target.c:  result = t->to_memory_map (t);
target.c:  for (t = current_target.beneath; t != NULL; t = t->beneath)
target.c:    if (t->to_flash_erase != NULL)
target.c:	  return t->to_flash_erase (t, address, length);
target.c:  for (t = current_target.beneath; t != NULL; t = t->beneath)
target.c:    if (t->to_flash_done != NULL)
target.c:	  return t->to_flash_done (t);
target.c:  if (target->to_stopped_data_address
target.c:  if (target->to_stopped_data_address == debug_to_stopped_data_address
target.c:  for (t = target_stack; t != NULL; t = t->beneath)
target.c:      if (!t->to_has_memory)
target.c:      if ((int) (t->to_stratum) <= (int) dummy_stratum)
target.c:      printf_unfiltered ("%s:\n", t->to_longname);
target.c:      (t->to_files_info) (t);
target.c:      has_all_mem = t->to_has_all_memory;
target.c:  for (t = current_target.beneath; t != NULL; t = t->beneath)
target.c:    if (t->to_disconnect != NULL)
target.c:	  t->to_disconnect (t, args, from_tty);
target.c:  for (t = current_target.beneath; t != NULL; t = t->beneath)
target.c:      if (t->to_follow_fork != NULL)
target.c:	  int retval = t->to_follow_fork (t, follow_child);
target.c:  (t->to_attach) (args, from_tty);
target.c:  (t->to_create_inferior) (exec_file, allargs, env, from_tty);
target.c:  old_value = target->to_sections;
target.c:  if (target->to_sections)
target.c:      old_count = target->to_sections_end - target->to_sections;
target.c:      target->to_sections = (struct section_table *)
target.c:	xrealloc ((char *) target->to_sections,
target.c:      target->to_sections = (struct section_table *)
target.c:  target->to_sections_end = target->to_sections + (num_added + old_count);
target.c:	      (*t)->to_sections = target->to_sections;
target.c:	      (*t)->to_sections_end = target->to_sections_end;
target.c:	  current_target.to_sections = target->to_sections;
target.c:	  current_target.to_sections_end = target->to_sections_end;
target.c:  return t->beneath;
target.c:		      (unsigned long) bp_tgt->placed_address,
target.c:		      (unsigned long) bp_tgt->placed_address,
target.c:		      (unsigned long) bp_tgt->placed_address,
target.c:		      (unsigned long) bp_tgt->placed_address,
target.c:  add_setshow_boolean_cmd ("trust-readonly-sections", class_support,
target.h:   of the debugger, and the part which is target-specific, or
target.h:   when the target is not on the target-stack, if the target_can_run
target.h:   This operation provides a target-specific hook that allows the
target.h:    /* Past-the-end address. */
thread.c:  /* NOTE: this will take care of any left-over step_resume breakpoints,
top.c:#include "event-top.h"
top.c:   event-top.c into this file, top.c */
top.c:   event-top.c into this file, top.c */
top.c:   event-top.c into this file, top.c */
top.c:      /* If this command has been post-hooked, run the hook last. */
top.c:   event-top.c into this file, top.c */
top.c:   synchronous mode.  So for operate-and-get-next to work in this
top.c:/* The current saved history number from operate-and-get-next.
top.c:/* This is put on the appropriate hook and helps operate-and-get-next
top.c:	  puts_unfiltered ("\n\032\032post-");
top.c:  immediate_quit--;
top.c:        target_detach (qt->args, qt->from_tty);
top.c:  rl_add_defun ("operate-and-get-next", gdb_rl_operate_and_get_next, 15);
top.c:  add_com ("dont-repeat", class_support, dont_repeat_command, _("\
top.h:/* For use by event-top.c */
tracepoint.c:  t->address = sal.pc;
tracepoint.c:    t->source_file = NULL;
tracepoint.c:    t->source_file = savestring (sal.symtab->filename,
tracepoint.c:  t->section = sal.section;
tracepoint.c:  t->language = current_language->la_language;
tracepoint.c:  t->input_radix = input_radix;
tracepoint.c:  t->line_number = sal.line;
tracepoint.c:  t->enabled_p = 1;
tracepoint.c:  t->next = 0;
tracepoint.c:  t->step_count = 0;
tracepoint.c:  t->pass_count = 0;
tracepoint.c:  t->addr_string = NULL;
tracepoint.c:      t->number = tracepoint_count;
tracepoint.c:	t->addr_string = canonical[i];
tracepoint.c:	t->addr_string = savestring (addr_start, addr_end - addr_start);
tracepoint.c:    if (tpnum == -1 || tpnum == t->number)
tracepoint.c:      printf_filtered ("%-3d %-3s ", t->number,
tracepoint.c:		       t->enabled_p ? "y" : "n");
tracepoint.c:	    tmp = hex_string_custom (t->address & (CORE_ADDR) 0xffffffff, 
tracepoint.c:	    tmp = hex_string_custom (t->address, 16);
tracepoint.c:      printf_filtered ("%-5d %-5ld ", t->pass_count, t->step_count);
tracepoint.c:      if (t->source_file)
tracepoint.c:	  sym = find_pc_sect_function (t->address, t->section);
tracepoint.c:	  fputs_filtered (t->source_file, gdb_stdout);
tracepoint.c:	  printf_filtered (":%d", t->line_number);
tracepoint.c:	print_address_symbolic (t->address, gdb_stdout, demangle, " ");
tracepoint.c:      if (t->actions)
tracepoint.c:	  printf_filtered ("  Actions for tracepoint %d: \n", t->number);
tracepoint.c:	  for (action = t->actions; action; action = action->next)
tracepoint.c:      t->enabled_p = 1;
tracepoint.c:      tracepoint_modify_event (t->number);
tracepoint.c:      t->enabled_p = 0;
tracepoint.c:      tracepoint_modify_event (t->number);
tracepoint.c:	tracepoint_chain = t->next;
tracepoint.c:	  t2->next = t->next;
tracepoint.c:      if (t->addr_string)
tracepoint.c:	xfree (t->addr_string);
tracepoint.c:      if (t->source_file)
tracepoint.c:	xfree (t->source_file);
tracepoint.c:      if (t->actions)
tracepoint.c:    if (t->number == tpnum)
tracepoint.c:	       t->number);
tracepoint.c:      t->step_count = 0;	/* read_actions may set this */
tracepoint.c:	t->actions = next = temp;
tracepoint.c:	  next->next = temp;
tracepoint.c:	      if (t->actions->next == NULL)
tracepoint.c:  immediate_quit--;
tracepoint.c:	  exp = parse_exp_1 (&p, block_for_pc (t->address), 1);
tracepoint.c:	  aexpr = gen_trace_for_expr (t->address, exp);
tracepoint.c:	  (t->step_count = strtol (p, &p, 0)) == 0)
tracepoint.c:  for (line = t->actions; line; line = next)
tracepoint.c:  t->actions = NULL;
tracepoint.c:  list->next_memrange = 0;
tracepoint.c:  for (ndx = 0; ndx < list->next_aexpr_elt; ndx++)
tracepoint.c:      free_agent_expr (list->aexpr_list[ndx]);
tracepoint.c:      list->aexpr_list[ndx] = NULL;
tracepoint.c:  list->next_aexpr_elt = 0;
tracepoint.c:  memset (list->regs_mask, 0, sizeof (list->regs_mask));
tracepoint.c:  count = 1 + list->next_memrange + list->next_aexpr_elt + 1;
tracepoint.c:  for (i = sizeof (list->regs_mask) - 1; i > 0; i--)
tracepoint.c:    if (list->regs_mask[i] != 0)	/* skip leading zeroes in regs_mask */
tracepoint.c:  if (list->regs_mask[i] != 0)	/* prepare to send regs_mask to the stub */
tracepoint.c:	    printf_filtered ("%02X", list->regs_mask[i]);
tracepoint.c:	  sprintf (end, "%02X", list->regs_mask[i]);
tracepoint.c:  if (list->next_memrange > 0 && info_verbose)
tracepoint.c:  for (i = 0, count = 0, end = temp_buf; i < list->next_memrange; i++)
tracepoint.c:      sprintf_vma (tmp2, list->list[i].start);
tracepoint.c:			   list->list[i].type, 
tracepoint.c:			   (long) (list->list[i].end - list->list[i].start));
tracepoint.c:        bfd_signed_vma length = list->list[i].end - list->list[i].start;
tracepoint.c:        if (list->list[i].type == memrange_absolute)
tracepoint.c:          sprintf (end, "M%X,%s,%lX", list->list[i].type, tmp2, (long) length);
tracepoint.c:  for (i = 0; i < list->next_aexpr_elt; i++)
tracepoint.c:      if ((count + 10 + 2 * list->aexpr_list[i]->len) > MAX_AGENT_EXPR_LEN)
tracepoint.c:      sprintf (end, "X%08X,", list->aexpr_list[i]->len);
tracepoint.c:      end = mem2hex (list->aexpr_list[i]->buf, 
tracepoint.c:		     end, list->aexpr_list[i]->len);
tracepoint.c:      count += 2 * list->aexpr_list[i]->len;
tracepoint.c:  TARGET_VIRTUAL_FRAME_POINTER (t->address, &frame_reg, &frame_offset);
tracepoint.c:  for (action = t->actions; action; action = action->next)
tracepoint.c:				     t->address,
tracepoint.c:				     t->address,
tracepoint.c:				     block_for_pc (t->address), 1);
tracepoint.c:		      aexpr = gen_trace_for_expr (t->address, exp);
tracepoint.c:  if (collect->next_aexpr_elt >= collect->aexpr_listsize)
tracepoint.c:      collect->aexpr_list =
tracepoint.c:	xrealloc (collect->aexpr_list,
tracepoint.c:		2 * collect->aexpr_listsize * sizeof (struct agent_expr *));
tracepoint.c:      collect->aexpr_listsize *= 2;
tracepoint.c:  collect->aexpr_list[collect->next_aexpr_elt] = aexpr;
tracepoint.c:  collect->next_aexpr_elt++;
tracepoint.c:   Allow trace mechanism to treat text-like sections
tracepoint.c:	sprintf_vma (tmp, t->address);
tracepoint.c:	sprintf (buf, "QTDP:%x:%s:%c:%lx:%x", t->number, 
tracepoint.c:		 t->enabled_p ? 'E' : 'D',
tracepoint.c:		 t->step_count, t->pass_count);
tracepoint.c:	if (t->actions)
tracepoint.c:	if (t->actions)
tracepoint.c:			     t->number, tmp, /* address */
tracepoint.c:			     t->number, tmp, /* address */
tracepoint.c:      /* Tell target to treat text-like sections as transparent.  */
tracepoint.c:	      count--;		/* don't count this one */
tracepoint.c:    if (t->number == tracepoint_number)
tracepoint.c:  stepping_frame = (t->address != (read_pc () - DECR_PC_AFTER_BREAK));
tracepoint.c:  for (action = t->actions; action; action = action->next)
tracepoint.c:  while (count-- > 0)
tracepoint.h:#define ALL_TRACEPOINTS(t)  for (t = tracepoint_chain; t; t = t->next)
tracepoint.h:	     t ? (tmp = t->next, 1) : 0;\
ui-out.c:  return &uiout->levels[uiout->level];
ui-out.c:  uiout->level++;
ui-out.c:  gdb_assert (uiout->level >= 0 && uiout->level < MAX_UI_OUT_LEVELS);
ui-out.c:  current->field_count = 0;
ui-out.c:  current->type = type;
ui-out.c:  return uiout->level;
ui-out.c:  gdb_assert (uiout->level > 0 && uiout->level < MAX_UI_OUT_LEVELS);
ui-out.c:  uiout->level--;
ui-out.c:  return uiout->level + 1;
ui-out.c:  if (uiout->table.flag)
ui-out.c:  uiout->table.flag = 1;
ui-out.c:  uiout->table.body_flag = 0;
ui-out.c:  uiout->table.entry_level = uiout->level + 1;
ui-out.c:  uiout->table.columns = nbrofcols;
ui-out.c:    uiout->table.id = xstrdup (tblid);
ui-out.c:    uiout->table.id = NULL;
ui-out.c:  uo_table_begin (uiout, nbrofcols, nr_rows, uiout->table.id);
ui-out.c:  if (!uiout->table.flag)
ui-out.c:  if (uiout->table.body_flag)
ui-out.c:  if (uiout->table.header_next->colno != uiout->table.columns)
ui-out.c:  uiout->table.body_flag = 1;
ui-out.c:  uiout->table.header_next = uiout->table.header_first;
ui-out.c:  if (!uiout->table.flag)
ui-out.c:  uiout->table.entry_level = 0;
ui-out.c:  uiout->table.body_flag = 0;
ui-out.c:  uiout->table.flag = 0;
ui-out.c:  if (uiout->table.id)
ui-out.c:    xfree (uiout->table.id);
ui-out.c:  if (!uiout->table.flag || uiout->table.body_flag)
ui-out.c:  if (uiout->table.flag && !uiout->table.body_flag)
ui-out.c:  if (uiout->table.body_flag
ui-out.c:      && uiout->table.entry_level == new_level)
ui-out.c:    uiout->table.header_next = uiout->table.header_first;
ui-out.c:  int oldflags = uiout->flags;
ui-out.c:  uiout->flags |= mask;
ui-out.c:  int oldflags = uiout->flags;
ui-out.c:  uiout->flags &= ~mask;
ui-out.c:  return (uiout->flags & mask);
ui-out.c:  return uiout->impl->is_mi_like_p;
ui-out.c:  if (!uiout->impl->table_begin)
ui-out.c:  uiout->impl->table_begin (uiout, nbrofcols, nr_rows, tblid);
ui-out.c:  if (!uiout->impl->table_body)
ui-out.c:  uiout->impl->table_body (uiout);
ui-out.c:  if (!uiout->impl->table_end)
ui-out.c:  uiout->impl->table_end (uiout);
ui-out.c:  if (!uiout->impl->table_header)
ui-out.c:  uiout->impl->table_header (uiout, width, align, col_name, colhdr);
ui-out.c:  if (uiout->impl->begin == NULL)
ui-out.c:  uiout->impl->begin (uiout, type, level, id);
ui-out.c:  if (uiout->impl->end == NULL)
ui-out.c:  uiout->impl->end (uiout, type, level);
ui-out.c:  if (!uiout->impl->field_int)
ui-out.c:  uiout->impl->field_int (uiout, fldno, width, align, fldname, value);
ui-out.c:  if (!uiout->impl->field_skip)
ui-out.c:  uiout->impl->field_skip (uiout, fldno, width, align, fldname);
ui-out.c:  if (!uiout->impl->field_string)
ui-out.c:  uiout->impl->field_string (uiout, fldno, width, align, fldname, string);
ui-out.c:  if (!uiout->impl->field_fmt)
ui-out.c:  uiout->impl->field_fmt (uiout, fldno, width, align, fldname, format, args);
ui-out.c:  if (!uiout->impl->spaces)
ui-out.c:  uiout->impl->spaces (uiout, numspaces);
ui-out.c:  if (!uiout->impl->text)
ui-out.c:  uiout->impl->text (uiout, string);
ui-out.c:  if (!uiout->impl->message)
ui-out.c:  uiout->impl->message (uiout, verbosity, format, args);
ui-out.c:  if (!uiout->impl->wrap_hint)
ui-out.c:  uiout->impl->wrap_hint (uiout, identstring);
ui-out.c:  if (!uiout->impl->flush)
ui-out.c:  uiout->impl->flush (uiout);
ui-out.c:  if (!uiout->impl->redirect)
ui-out.c:  uiout->impl->redirect (uiout, outstream);
ui-out.c:  while (uiout->table.header_first != NULL)
ui-out.c:      uiout->table.header_next = uiout->table.header_first;
ui-out.c:      uiout->table.header_first = uiout->table.header_first->next;
ui-out.c:      if (uiout->table.header_next->colhdr != NULL)
ui-out.c:	xfree (uiout->table.header_next->colhdr);
ui-out.c:      xfree (uiout->table.header_next);
ui-out.c:  gdb_assert (uiout->table.header_first == NULL);
ui-out.c:  uiout->table.header_last = NULL;
ui-out.c:  uiout->table.header_next = NULL;
ui-out.c:  if (uiout->table.header_first == NULL)
ui-out.c:      uiout->table.header_first = temphdr;
ui-out.c:      uiout->table.header_last = temphdr;
ui-out.c:      temphdr->colno = uiout->table.header_last->colno + 1;
ui-out.c:      uiout->table.header_last->next = temphdr;
ui-out.c:      uiout->table.header_last = temphdr;
ui-out.c:  uiout->table.header_next = uiout->table.header_last;
ui-out.c:  if (uiout->table.header_next == NULL)
ui-out.c:  *colno = uiout->table.header_next->colno;
ui-out.c:  *width = uiout->table.header_next->width;
ui-out.c:  *alignment = uiout->table.header_next->alignment;
ui-out.c:  *colhdr = uiout->table.header_next->colhdr;
ui-out.c:  uiout->table.header_next = uiout->table.header_next->next;
ui-out.c:  if (uiout->table.flag)
ui-out.c:      if (!uiout->table.body_flag)
ui-out.c:	 that this code was only executed when uiout->level was
ui-out.c:  current->field_count += 1;
ui-out.c:  if (uiout->table.body_flag
ui-out.c:      && uiout->table.entry_level == uiout->level
ui-out.c:      if (*fldno != current->field_count)
ui-out.c:      *fldno = current->field_count;
ui-out.c:  return uiout->data;
ui-out.c:  uiout->data = data;
ui-out.c:  uiout->impl = impl;
ui-out.c:  uiout->flags = flags;
ui-out.c:  uiout->table.flag = 0;
ui-out.c:  uiout->table.body_flag = 0;
ui-out.c:  uiout->level = 0;
ui-out.c:  memset (uiout->levels, 0, sizeof (uiout->levels));
ui-out.c:  uiout->table.header_first = NULL;
ui-out.c:  uiout->table.header_last = NULL;
ui-out.c:  uiout->table.header_next = NULL;
ui-out.h:   like a  ui-out-impl.h  file */
ui-out.h:/* ui-out-impl */
utils.c:#include "event-top.h"
utils.c:    printf_filtered (("\n\032\032post-query\n"));
utils.c:    printf_unfiltered (("\n\032\032pre-prompt-for-continue\n"));
utils.c:	  "---Type <return> to continue, or q <return> to quit---");
utils.c:    strcat (cont_prompt, "\n\032\032prompt-for-continue\n");
utils.c:    printf_unfiltered (("\n\032\032post-prompt-for-continue\n"));
utils.c:  immediate_quit--;
utils.c:  add_setshow_boolean_cmd ("sevenbit-strings", class_support,
uw-thread.c:/* procfs.c's target-specific operations.  */
uw-thread.c:/* This module's target-specific operations.  */
v850-tdep.c:/* Target-dependent code for the NEC V850 for GDB, the GNU debugger.
valarith.c:      /* FIXME-if-picky-about-floating-accuracy: Should be doing this
valops.c:     runtime spec. (Depth-first, left-to-right.)  */
valprint.c:   FORMAT is a format-letter, or 0 for print in natural format of data type.
valprint.c:   the 'set input-radix' command. */
valprint.c:  add_setshow_uinteger_cmd ("input-radix", class_support, &input_radix, _("\
valprint.c:  add_setshow_uinteger_cmd ("output-radix", class_support, &output_radix, _("\
valprint.c:Use 'set input-radix' or 'set output-radix' to independently set each.\n\
valprint.c:Use 'show input-radix' or 'show output-radix' to independently show each."),
value.c:  for (val = next = all_values; next; next = next->next)
value.c:    if (next->next == mark)
value.c:	all_values = next->next;
value.c:	next->next = NULL;
value.c:    error (_("Init-if-undefined requires an assignment expression."));
value.c:    error (_("The first parameter to init-if-undefined should be a GDB variable."));
value.c:   C++: It is assumed that the front-end has taken care of
value.c:	 bit-rotten.  The target needs to add definitions for the
value.c:   C++: It is assumed that the front-end has taken care of
value.c:  add_com ("init-if-undefined", class_vars, init_if_undefined_command, _("\
value.c:init-if-undefined VARIABLE = EXPRESSION\n\
varobj.c:	var->root->use_selected_frame = 1;
varobj.c:      if (!gdb_parse_exp_1 (&p, block, 0, &var->root->exp))
varobj.c:      if (var->root->exp->elts[0].opcode == OP_TYPE)
varobj.c:      var->root->valid_block = innermost_block;
varobj.c:	  var->root->frame = get_frame_id (fi);
varobj.c:      if (gdb_evaluate_expression (var->root->exp, &var->value))
varobj.c:	var->value = evaluate_type (var->root->exp);
varobj.c:      var->root->lang = languages[lang];
varobj.c:      var->root->rootvar = var;
varobj.c:	  mycount--;
varobj.c:      *cv = croot->rootvar;
varobj.c:      mycount--;
varobj.c:      croot = croot->next;
varobj.c:  if ((*varp)->root->rootvar != *varp)
varobj.c:      vleft--;
varobj.c:  if (var->root->rootvar == var)
varobj.c:	var->root->next = NULL;
varobj.c:	var->root->next = rootlist;
varobj.c:  if (var->root->rootvar == var)
varobj.c:	rootlist = var->root->next;
varobj.c:      rootcount--;
varobj.c:  if ((!CPLUS_FAKE_CHILD (child) && child->value == NULL) || parent->error)
varobj.c:  child->root = parent->root;
varobj.c:  childs_name = xstrprintf ("%s.%s", parent->obj_name, name);
varobj.c:  vc = parent->children;
varobj.c:  parent->children =
varobj.c:  parent->children->next = vc;
varobj.c:  parent->children->child = child;
varobj.c:  for (vc = parent->children; vc != NULL;)
varobj.c:    parent->children = vc->next;
varobj.c:  var->root->lang = NULL;
varobj.c:  var->root->exp = NULL;
varobj.c:  var->root->valid_block = NULL;
varobj.c:  var->root->frame = null_frame_id;
varobj.c:  var->root->use_selected_frame = 0;
varobj.c:  var->root->rootvar = NULL;
varobj.c:  if (var->root->rootvar == var)
varobj.c:      free_current_contents (&var->root->exp);
varobj.c:  switch (var->root->exp->language_defn->la_language)
varobj.c:  return (*var->root->lang->number_of_children) (var);;
varobj.c:  return (*var->root->lang->name_of_variable) (var);
varobj.c:  return (*var->root->lang->name_of_child) (var, index);
varobj.c:  if (var->root->rootvar != var)
varobj.c:  if (var->root->use_selected_frame)
varobj.c:  return (*var->root->lang->value_of_root) (var_handle);
varobj.c:  value = (*parent->root->lang->value_of_child) (parent, index);
varobj.c:  return (*var->root->lang->type_of_child) (var->parent, var->index);
varobj.c:  return (*var->root->lang->variable_editable) (var);
varobj.c:  return (*var->root->lang->value_of_variable) (var);
varobj.c:  return savestring (parent->name, strlen (parent->name));
varobj.c:	  name = xstrprintf ("*%s", parent->name);
varobj.c:  if (var->root->rootvar != var)
varobj.c:  if (var->root->valid_block == NULL)
varobj.c:      fi = frame_find_by_id (var->root->frame);
varobj.c:      if (gdb_evaluate_expression (var->root->exp, &new_val))
varobj.c:  temp = parent->value;
varobj.c:  switch (TYPE_CODE (parent->type))
varobj.c:      type = get_target_type (parent->type);
varobj.c:      type = lookup_struct_elt_type (parent->type, name, 0);
varobj.c:      switch (TYPE_CODE (get_target_type (parent->type)))
varobj.c:	  type = lookup_struct_elt_type (parent->type, name, 0);
varobj.c:	  type = get_target_type (parent->type);
varobj.c:      type = get_type_deref (parent->parent);
varobj.c:	  if (strcmp (parent->name, "private") == 0)
varobj.c:	  else if (strcmp (parent->name, "protected") == 0)
varobj.c:    type = get_type_deref (parent->parent);
varobj.c:	  struct value *temp = parent->parent->value;
varobj.c:	  if (parent->value != NULL)
varobj.c:	      if (TYPE_CODE (value_type (parent->value)) == TYPE_CODE_PTR)
varobj.c:		  if (!gdb_value_ind (parent->value, &temp))
varobj.c:		temp = parent->value;
varobj.c:      t = get_type_deref (parent->parent);
vaxbsd-nat.c:  t->to_fetch_registers = vaxbsd_fetch_inferior_registers;
vaxbsd-nat.c:  t->to_store_registers = vaxbsd_store_inferior_registers;
vaxnbsd-tdep.c:/* Target-dependent code for NetBSD/vax.
vaxobsd-tdep.c:/* Target-dependent code for OpenBSD/vax.
vaxobsd-tdep.c:  if (strcmp (bfd_get_target (abfd), "a.out-vax-netbsd") == 0)
vax-tdep.c:/* Target-dependent code for the VAX.
vax-tdep.h:/* Target-dependent code for the VAX.
vec.h:   out-of-line generic functions.
vec.h:   object variant is suitable for int-like objects, and the vector
win32-nat.c:/* Target-vector operations for controlling win32 child processes, for GDB.
win32-nat.c:       th->next != NULL && th->next->id != id;
win32-nat.c:  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
win32-nat.c:    dll_name = get_image_name (current_process_handle, event->lpImageName, event->fUnicode);
win32-nat.c:  register_loaded_dll (dll_name, (DWORD) event->lpBaseOfDll + 0x1000, auto_solib_add);
win32-nat.c:    if (so->next->lm_info->load_addr == lpBaseOfDll)
win32-nat.c:  if (sect->flags & SEC_CODE)
win32-nat.c:      update_coreops = core_ops.to_sections == target->to_sections;
win32-nat.c:      if (target->to_sections)
win32-nat.c:	  old = target->to_sections_end - target->to_sections;
win32-nat.c:	  target->to_sections = (struct section_table *)
win32-nat.c:	    xrealloc ((char *) target->to_sections,
win32-nat.c:	  target->to_sections = (struct section_table *)
win32-nat.c:      target->to_sections_end = target->to_sections + (1 + old);
win32-nat.c:	  core_ops.to_sections = target->to_sections;
win32-nat.c:	  core_ops.to_sections_end = target->to_sections_end;
win32-nat.c:      new_target_sect_ptr = target->to_sections + old;
win32-nat.c:  if (strncmp (sect->name, ".module", 7) != 0)
win32-nat.c:      printf_unfiltered ("memory allocation failed for %s\n", sect->name);
win32-nat.c:	  last->next = new;
wince.c:/* Target-vector operations for controlling Windows CE child processes, for GDB.
wince.c:       th->next != NULL && th->next->id != id;
wince.c:  if (!event->lpImageName)
wince.c:  for (bufp = dll_buf, imgp = event->lpImageName;
wince.c:	  if (event->fUnicode)
wince.c:  if (!event->fUnicode)
wince.c:  printf_unfiltered ("%x:%s", event->lpBaseOfDll, dll_name);
wince-stub.c:	      skip_next--;
xcoffread.c:  if (sect->target_index == args->targ_index)
xcoffread.c:	*args->resultp = sect->index;
xcoffread.c:  struct objfile *objfile = pst->objfile;
xcoffread.c:  symnum = ((struct symloc *) pst->read_symtab_private)->first_symnum;
xcoffread.c:    symnum + ((struct symloc *) pst->read_symtab_private)->numsyms;
xcoffread.c:	      pst->symtab =
xcoffread.c:         to make sure that we set pst->symtab to the symtab for the
xcoffread.c:      if (pst->symtab == NULL)
xcoffread.c:	pst->symtab = s;
xcoffread.c:  count = asect->lineno_count;
xcoffread.c:  if (!DEPRECATED_STREQ (asect->name, ".text") || count == 0)
xcoffread.c:  offset = asect->line_filepos;
xcoffread.c:  if (pst->readin)
xcoffread.c:	 pst->filename);
xcoffread.c:  for (i = 0; i < pst->number_of_dependencies; i++)
xcoffread.c:    if (!pst->dependencies[i]->readin)
xcoffread.c:	    printf_filtered ("%s...", pst->dependencies[i]->filename);
xcoffread.c:	xcoff_psymtab_to_symtab_1 (pst->dependencies[i]);
xcoffread.c:  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0)
xcoffread.c:  pst->readin = 1;
xcoffread.c:  if (pst->readin)
xcoffread.c:	 pst->filename);
xcoffread.c:  if (((struct symloc *) pst->read_symtab_private)->numsyms != 0
xcoffread.c:      || pst->number_of_dependencies)
xcoffread.c:	  printf_filtered ("Reading in symbols for %s...", pst->filename);
xcoffread.c:      sym_bfd = pst->objfile->obfd;
xcoffread.c:      scan_file_globals (pst->objfile);
xcoffread.c:  result->read_symtab_private = (char *)
xcoffread.c:  ((struct symloc *) result->read_symtab_private)->first_symnum = first_symnum;
xcoffread.c:  result->read_symtab = xcoff_psymtab_to_symtab;
xcoffread.c:  struct objfile *objfile = pst->objfile;
xcoffread.c:    ((struct symloc *) pst->read_symtab_private)->numsyms =
xcoffread.c:      - ((struct symloc *) pst->read_symtab_private)->first_symnum;
xcoffread.c:  ((struct symloc *) pst->read_symtab_private)->lineno_off =
xcoffread.c:  pst->n_global_syms =
xcoffread.c:    objfile->global_psymbols.next - (objfile->global_psymbols.list + pst->globals_offset);
xcoffread.c:  pst->n_static_syms =
xcoffread.c:    objfile->static_psymbols.next - (objfile->static_psymbols.list + pst->statics_offset);
xcoffread.c:  pst->number_of_dependencies = number_dependencies;
xcoffread.c:      pst->dependencies = (struct partial_symtab **)
xcoffread.c:      memcpy (pst->dependencies, dependency_list,
xcoffread.c:    pst->dependencies = 0;
xcoffread.c:      subpst->section_offsets = pst->section_offsets;
xcoffread.c:      subpst->read_symtab_private =
xcoffread.c:      ((struct symloc *) subpst->read_symtab_private)->first_symnum = 0;
xcoffread.c:      ((struct symloc *) subpst->read_symtab_private)->numsyms = 0;
xcoffread.c:      subpst->textlow = 0;
xcoffread.c:      subpst->texthigh = 0;
xcoffread.c:      subpst->dependencies = (struct partial_symtab **)
xcoffread.c:      subpst->dependencies[0] = pst;
xcoffread.c:      subpst->number_of_dependencies = 1;
xcoffread.c:      subpst->globals_offset =
xcoffread.c:	subpst->n_global_syms =
xcoffread.c:	subpst->statics_offset =
xcoffread.c:	subpst->n_static_syms = 0;
xcoffread.c:      subpst->readin = 0;
xcoffread.c:      subpst->symtab = 0;
xcoffread.c:      subpst->read_symtab = pst->read_symtab;
xcoffread.c:  free_named_symtabs (pst->filename);
xcoffread.c:      && pst->n_global_syms == 0
xcoffread.c:      && pst->n_static_syms == 0)
xcoffread.c:	    /* The CSECT auxent--always the last auxent.  */
xcoffread.c:			if (highval > pst->texthigh)
xcoffread.c:			  pst->texthigh = highval;
xcoffread.c:			if (pst->textlow == 0 || symbol.n_value < pst->textlow)
xcoffread.c:			  pst->textlow = symbol.n_value;
xcoffread.c:	    if (pst && DEPRECATED_STREQ (namestring, pst->filename))
xcoffread.c:    objfile->sect_index_text = sect->index;
xcoffread.c:    objfile->sect_index_data = sect->index;
xcoffread.c:    objfile->sect_index_bss = sect->index;
xcoffread.c:    objfile->sect_index_rodata = sect->index;
xcoffread.c:  xcoff_symfile_offsets,	/* sym_offsets: xlate offsets ext->int form */
xstormy16-tdep.c:/* Target-dependent code for the Sanyo Xstormy16a (LC590000) processor.
xstormy16-tdep.c:     consume one argument-passing register.  */
xstormy16-tdep.c:      if (strcmp (faddr_sect->the_bfd_section->name, ".plt"))
xstormy16-tdep.c:      if (!strcmp (faddr_sect->the_bfd_section->name, ".plt"))
xstormy16-tdep.c:      ALL_OBJFILE_OSECTIONS (faddr_sect->objfile, osect)
xstormy16-tdep.c:	if (!strcmp (osect->the_bfd_section->name, ".plt"))
xstormy16-tdep.c:      if (osect < faddr_sect->objfile->sections_end)
xstormy16-tdep.c:	  for (addr = osect->addr;
xstormy16-tdep.c:	       addr < osect->endaddr; addr += 2 * xstormy16_inst_size)
xstormy16-tdep.c:   Called by gdb at start-up. */
xtensa-tdep.c:/* Target-dependent code for the Xtensa port of GDB, the GNU debugger.
xtensa-tdep.c:	     will be left-aligned in the register on both endiannesses.  */
xtensa-tdep.h:/* Target-dependent code for the Xtensa port of GDB, the GNU debugger.
xtensa-tdep.h:   Copied from target-side ELF header <xtensa/elf.h>.  */
